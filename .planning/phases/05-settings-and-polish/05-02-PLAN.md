---
phase: 05-settings-and-polish
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - Pastel/Views/Settings/LabelSettingsView.swift
  - Pastel/Views/Settings/SettingsView.swift
  - Pastel/Views/Panel/FilteredCardListView.swift
  - Pastel/Views/Panel/PanelContentView.swift
autonomous: true

must_haves:
  truths:
    - "User opens Labels tab in settings and sees all existing labels"
    - "User creates a new label from the Labels tab"
    - "User renames a label by clicking its name"
    - "User recolors a label by clicking its color dot and selecting from a palette"
    - "User deletes a label and associated items become unlabeled"
    - "When panel is at top or bottom edge, cards scroll horizontally"
    - "When panel is at left or right edge, cards scroll vertically (existing behavior)"
    - "Arrow key navigation maps to the correct axis (up/down for vertical, left/right for horizontal)"
  artifacts:
    - path: "Pastel/Views/Settings/LabelSettingsView.swift"
      provides: "Label CRUD list for Settings Labels tab"
      contains: "struct LabelSettingsView"
    - path: "Pastel/Views/Panel/FilteredCardListView.swift"
      provides: "Adaptive layout -- LazyVStack for vertical edges, LazyHStack for horizontal edges"
      contains: "LazyHStack"
  key_links:
    - from: "Pastel/Views/Settings/SettingsView.swift"
      to: "LabelSettingsView"
      via: "tab switch in SettingsView"
      pattern: "LabelSettingsView"
    - from: "Pastel/Views/Panel/FilteredCardListView.swift"
      to: "PanelEdge"
      via: "@AppStorage panelEdge read"
      pattern: "AppStorage.*panelEdge"
    - from: "Pastel/Views/Panel/PanelContentView.swift"
      to: "PanelEdge"
      via: "@AppStorage panelEdge for layout direction"
      pattern: "AppStorage.*panelEdge"
---

<objective>
Labels tab in settings with full CRUD, and horizontal panel layout adaptation for top/bottom edges with arrow key direction swap.

Purpose: Completes the settings window (Labels tab) and ensures the panel renders correctly when positioned at top or bottom screen edges. Without this, changing panel position to top/bottom would show a broken vertical layout in a short horizontal space.

Output: LabelSettingsView with create/rename/recolor/delete, FilteredCardListView with adaptive vertical/horizontal layout, and correct arrow key mapping per orientation.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-settings-and-polish/05-RESEARCH.md
@.planning/phases/05-settings-and-polish/05-CONTEXT.md
@.planning/phases/05-settings-and-polish/05-01-SUMMARY.md
@Pastel/Views/Panel/FilteredCardListView.swift
@Pastel/Views/Panel/PanelContentView.swift
@Pastel/Views/Panel/ClipboardCardView.swift
@Pastel/Models/Label.swift
@Pastel/Models/LabelColor.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: LabelSettingsView with full CRUD and wire into SettingsView</name>
  <files>
    Pastel/Views/Settings/LabelSettingsView.swift
    Pastel/Views/Settings/SettingsView.swift
  </files>
  <action>
**Create `Pastel/Views/Settings/LabelSettingsView.swift`:**

A vertical list of label rows with inline editing, plus a "+" button to create new labels. Uses `@Query(sort: \Label.sortOrder) private var labels: [Label]` and `@Environment(\.modelContext) private var modelContext`.

Layout: VStack(alignment: .leading, spacing: 0) containing:
1. Header row: HStack with Text("Labels").font(.headline) on the left and a "+" button on the right.
2. Divider
3. ScrollView containing a LazyVStack(spacing: 0) of label rows. If labels is empty, show a centered empty state: Text("No labels yet").foregroundStyle(.secondary).

**Each label row (`LabelRow` - define as a private struct or inline):**

Per the RESEARCH.md LabelRow pattern:
- HStack(spacing: 12) containing:
  1. **Color dot** (tap to recolor): Use a `Menu` with the color dot as label. Menu items: `ForEach(LabelColor.allCases, id: \.self)` with a Button per color that sets `label.colorName = color.rawValue` and saves. The dot is `Circle().fill(LabelColor(rawValue: label.colorName)?.color ?? .gray).frame(width: 14, height: 14)`.
  2. **Name** (click to edit): Use `@State private var isEditing = false`. When not editing, show `Text(label.name).onTapGesture { isEditing = true }`. When editing, show `TextField("Label name", text: $label.name).textFieldStyle(.plain).onSubmit { isEditing = false; try? modelContext.save() }`.
  3. **Spacer()**
  4. **Delete button**: `Button(role: .destructive) { deleteLabel(label) }` with trash icon. No confirmation dialog per CONTEXT.md ("no confirmation").
- Use `@Bindable var label: Label` for the label parameter so TextField can bind directly.
- Padding: `.padding(.vertical, 8).padding(.horizontal, 12)`
- Add a subtle bottom divider between rows.

**Delete logic:**
```swift
private func deleteLabel(_ label: Label) {
    modelContext.delete(label)
    try? modelContext.save()
}
```
The `.nullify` delete rule on Label's @Relationship handles setting `item.label = nil` automatically. No manual cascade needed.

**Create logic (the "+" button):**
- Tapping "+" inserts a new Label with name "New Label", color "blue", sortOrder = (max sortOrder + 1).
- Save immediately. The row appears in the list with inline editing ready.

**Modify `Pastel/Views/Settings/SettingsView.swift`:**

Replace the placeholder `Text("Labels")` in the Labels tab case with `LabelSettingsView()`.
  </action>
  <verify>
Run `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild -scheme Pastel -destination 'platform=macOS' build 2>&1 | tail -5` -- must compile with zero errors. Verify LabelSettingsView.swift exists. Verify SettingsView.swift references LabelSettingsView (not placeholder text).
  </verify>
  <done>
Labels tab in settings shows a scrollable list of all labels. User can create new labels with "+" button, rename by clicking the name, recolor by clicking the color dot (Menu with palette), and delete with the trash button. Deletion nullifies the relationship automatically via SwiftData delete rule.
  </done>
</task>

<task type="auto">
  <name>Task 2: Adaptive horizontal/vertical layout for FilteredCardListView + keyboard nav direction swap</name>
  <files>
    Pastel/Views/Panel/FilteredCardListView.swift
    Pastel/Views/Panel/PanelContentView.swift
  </files>
  <action>
**Modify `Pastel/Views/Panel/FilteredCardListView.swift`:**

The current view uses LazyVStack unconditionally. It must adapt based on the panel edge setting.

1. Add `@AppStorage("panelEdge") private var panelEdgeRaw: String = PanelEdge.right.rawValue` at the top of the struct.
2. Add a computed property:
   ```swift
   private var isHorizontal: Bool {
       let edge = PanelEdge(rawValue: panelEdgeRaw) ?? .right
       return !edge.isVertical
   }
   ```
3. In the `body`, replace the single `ScrollViewReader { proxy in ScrollView { LazyVStack ... } }` with a conditional:

   ```swift
   if isHorizontal {
       // Horizontal layout for top/bottom edges
       ScrollViewReader { proxy in
           ScrollView(.horizontal, showsIndicators: false) {
               LazyHStack(spacing: 8) {
                   ForEach(Array(items.enumerated()), id: \.element.id) { index, item in
                       ClipboardCardView(item: item, isSelected: selectedIndex == index)
                           .frame(width: 260)
                           .id(index)
                           .onTapGesture(count: 2) { onPaste(item) }
                           .onTapGesture(count: 1) { selectedIndex = index }
                   }
               }
               .padding(.horizontal, 10)
               .padding(.vertical, 8)
           }
           .onChange(of: selectedIndex) { _, newValue in
               if let newValue {
                   withAnimation(.easeInOut(duration: 0.15)) {
                       proxy.scrollTo(newValue, anchor: .center)
                   }
               }
           }
       }
   } else {
       // Existing vertical layout for left/right edges
       ScrollViewReader { proxy in
           ScrollView {
               LazyVStack(spacing: 8) {
                   // ... existing ForEach code unchanged
               }
               .padding(.horizontal, 10)
               .padding(.vertical, 8)
           }
           .onChange(of: selectedIndex) { _, newValue in
               if let newValue {
                   withAnimation(.easeInOut(duration: 0.15)) {
                       proxy.scrollTo(newValue, anchor: .center)
                   }
               }
           }
       }
   }
   ```

4. **Swap keyboard navigation axis.** Replace the current `.onKeyPress` handlers with direction-aware versions. The keyboard handlers are on the outer Group, so they apply to both layouts:

   ```swift
   .onKeyPress(.upArrow) {
       if !isHorizontal { moveSelection(by: -1) }
       return isHorizontal ? .ignored : .handled
   }
   .onKeyPress(.downArrow) {
       if !isHorizontal { moveSelection(by: 1) }
       return isHorizontal ? .ignored : .handled
   }
   .onKeyPress(.leftArrow) {
       if isHorizontal { moveSelection(by: -1) }
       return isHorizontal ? .handled : .ignored
   }
   .onKeyPress(.rightArrow) {
       if isHorizontal { moveSelection(by: 1) }
       return isHorizontal ? .handled : .ignored
   }
   .onKeyPress(.return) {
       if let index = selectedIndex, index < items.count {
           onPaste(items[index])
       }
       return .handled
   }
   ```

   This means: vertical panel (left/right edges) uses up/down arrows. Horizontal panel (top/bottom edges) uses left/right arrows. Enter always pastes.

5. Keep the empty state view, `.focusable()`, `.focusEffectDisabled()`, and `.onAppear` unchanged.

**Modify `Pastel/Views/Panel/PanelContentView.swift`:**

When the panel is in horizontal mode (top/bottom), the overall layout should still be the same VStack (header, divider, search, chipbar, filtered list) but the filtered list area will scroll horizontally due to FilteredCardListView's internal change. No layout changes needed in PanelContentView itself -- the VStack stacking still works because the ScrollView inside FilteredCardListView handles the horizontal direction internally.

However, ensure the `.frame(maxWidth: .infinity, maxHeight: .infinity)` on the root VStack still allows proper sizing in both orientations. This should work as-is because the panel frame (set by PanelController) determines the available space.

No changes to PanelContentView are needed beyond what was done in Task 2 of Plan 01 (the gear icon). The layout adapts because FilteredCardListView reads @AppStorage internally.
  </action>
  <verify>
Run `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild -scheme Pastel -destination 'platform=macOS' build 2>&1 | tail -5` -- must compile with zero errors. Verify FilteredCardListView.swift contains both `LazyVStack` and `LazyHStack` paths. Verify `.onKeyPress(.leftArrow)` and `.onKeyPress(.rightArrow)` handlers exist. Verify `@AppStorage("panelEdge")` is read in FilteredCardListView.
  </verify>
  <done>
When panel edge is left or right, cards scroll vertically in a LazyVStack with up/down arrow navigation (unchanged from existing behavior). When panel edge is top or bottom, cards scroll horizontally in a LazyHStack with fixed 260pt width per card and left/right arrow navigation. Enter key always pastes the selected item. Layout adapts automatically when @AppStorage("panelEdge") changes.
  </done>
</task>

</tasks>

<verification>
- [ ] `xcodebuild -scheme Pastel -destination 'platform=macOS' build` succeeds with zero errors
- [ ] LabelSettingsView.swift exists with @Query for labels, create/rename/recolor/delete functionality
- [ ] SettingsView.swift switches to LabelSettingsView() for the Labels tab (no placeholder)
- [ ] FilteredCardListView.swift reads @AppStorage("panelEdge") and branches to LazyHStack for horizontal edges
- [ ] Cards in horizontal mode have `.frame(width: 260)` for fixed-width cards
- [ ] Keyboard navigation: up/down for vertical panel, left/right for horizontal panel, Enter for paste in both
- [ ] Label creation inserts a new Label with default name and color
- [ ] Label deletion calls modelContext.delete (SwiftData .nullify rule handles cascade)
- [ ] Label rename works via inline TextField with .onSubmit save
- [ ] Label recolor works via Menu with LabelColor.allCases palette
</verification>

<success_criteria>
1. Build succeeds -- zero errors from xcodebuild
2. Labels tab complete -- LabelSettingsView with create, rename, recolor, delete
3. Horizontal layout works -- top/bottom panel edges show cards in a horizontal LazyHStack scroll
4. Keyboard nav adapts -- left/right arrows for horizontal mode, up/down for vertical mode
5. Phase 5 is feature-complete: all 3 requirements (INFR-02, INFR-03, PNUI-03) are fully delivered across plans 01 and 02
</success_criteria>

<output>
After completion, create `.planning/phases/05-settings-and-polish/05-02-SUMMARY.md`
</output>
