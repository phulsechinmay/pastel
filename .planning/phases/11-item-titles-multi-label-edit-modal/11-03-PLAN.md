---
phase: 11-item-titles-multi-label-edit-modal
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - Pastel/Views/Panel/ChipBarView.swift
  - Pastel/Views/Panel/PanelContentView.swift
  - Pastel/Views/Panel/FilteredCardListView.swift
autonomous: true

must_haves:
  truths:
    - "User can tap multiple label chips to select them simultaneously (multi-select)"
    - "Chip bar filtering shows items that have ANY of the selected labels (OR logic)"
    - "Search matches against item titles in addition to content text and app name"
    - "Dragging a label chip onto a card appends the label (does not replace)"
    - "FilteredCardListView recreates when selected labels change (via .id())"
  artifacts:
    - path: "Pastel/Views/Panel/ChipBarView.swift"
      provides: "Multi-select chip bar with Set<PersistentIdentifier> binding"
      contains: "selectedLabelIDs"
    - path: "Pastel/Views/Panel/PanelContentView.swift"
      provides: "Multi-label state and updated .id() trigger"
      contains: "selectedLabelIDs"
    - path: "Pastel/Views/Panel/FilteredCardListView.swift"
      provides: "Hybrid filtering (predicate for text, in-memory for labels), title search, drag-drop append"
      contains: "filteredItems"
  key_links:
    - from: "Pastel/Views/Panel/PanelContentView.swift"
      to: "Pastel/Views/Panel/ChipBarView.swift"
      via: "$selectedLabelIDs binding"
      pattern: "selectedLabelIDs"
    - from: "Pastel/Views/Panel/PanelContentView.swift"
      to: "Pastel/Views/Panel/FilteredCardListView.swift"
      via: "selectedLabelIDs parameter and .id() recreation"
      pattern: "selectedLabelIDs.*id\\("
    - from: "Pastel/Views/Panel/FilteredCardListView.swift"
      to: "Pastel/Models/ClipboardItem.swift"
      via: "item.labels for in-memory filtering and title in search predicate"
      pattern: "item\\.labels\\.contains|item\\.title"
---

<objective>
Convert the chip bar from single-select to multi-select, implement hybrid label filtering (SwiftData predicate for text search + in-memory post-filter for multi-label OR logic), add title to the search predicate, and update drag-drop to append labels instead of replacing.

Purpose: This completes the multi-label filtering pipeline so users can select multiple labels and search by title.
Output: Fully functional multi-label filtering with OR logic, title search, and drag-drop label append.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-item-titles-multi-label-edit-modal/11-RESEARCH.md
@.planning/phases/11-item-titles-multi-label-edit-modal/11-01-SUMMARY.md

Key files to read:
@Pastel/Views/Panel/ChipBarView.swift
@Pastel/Views/Panel/PanelContentView.swift
@Pastel/Views/Panel/FilteredCardListView.swift
@Pastel/Models/ClipboardItem.swift (updated in Plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert ChipBarView to multi-select and update PanelContentView state</name>
  <files>
    Pastel/Views/Panel/ChipBarView.swift
    Pastel/Views/Panel/PanelContentView.swift
  </files>
  <action>
**ChipBarView.swift:**

1. Change the binding from `@Binding var selectedLabel: Label?` to `@Binding var selectedLabelIDs: Set<PersistentIdentifier>`.

2. Update `labelChip(for:)`:
   - Change `let isActive = selectedLabel?.persistentModelID == label.persistentModelID` to `let isActive = selectedLabelIDs.contains(label.persistentModelID)`.
   - Change the `.onTapGesture` toggle logic:
     ```swift
     .onTapGesture {
         if isActive {
             selectedLabelIDs.remove(label.persistentModelID)
         } else {
             selectedLabelIDs.insert(label.persistentModelID)
         }
     }
     ```

3. The draggable modifier on chips remains unchanged (it drags a single label ID for drop targets).

4. Everything else (create chip, create label popover, chip background) stays the same. The `chipBackground` method's `isActive` parameter is already a Bool, so no change needed there.

**PanelContentView.swift:**

1. Change `@State private var selectedLabel: Label? = nil` to `@State private var selectedLabelIDs: Set<PersistentIdentifier> = []`.

2. Update both ChipBarView usages (horizontal mode ~line 51 and vertical mode ~line 99):
   - Change `ChipBarView(labels: labels, selectedLabel: $selectedLabel)` to `ChipBarView(labels: labels, selectedLabelIDs: $selectedLabelIDs)`.

3. Update the FilteredCardListView instantiation (~line 103):
   - Change `selectedLabelID: selectedLabel?.persistentModelID` to `selectedLabelIDs: selectedLabelIDs`.

4. Update the `.id()` modifier (~line 117). The current `.id()` uses `selectedLabel?.persistentModelID.hashValue ?? 0`. Replace with a stable string representation of the selected label IDs set:
   ```swift
   .id("\(debouncedSearchText)\(selectedLabelIDs.sorted(by: { "\($0)" < "\($1)" }).map { "\($0)" }.joined())\(appState.itemCount)")
   ```
   **Critical pitfall from RESEARCH.md:** Sets don't have stable hash values across runs. Convert to a sorted string representation for the `.id()` modifier. Using `.hashValue` on a Set could produce different values for the same set contents.

5. Update `.onChange(of: selectedLabel)` (~line 142) to `.onChange(of: selectedLabelIDs)`:
   ```swift
   .onChange(of: selectedLabelIDs) { _, _ in
       panelFocus = .cardList
   }
   ```
   Note: `Set<PersistentIdentifier>` conforms to Equatable, so `.onChange` works.
  </action>
  <verify>
Build succeeds. ChipBarView compiles with Set binding. PanelContentView compiles with updated state. Multiple chips can be visually selected (accent border on multiple).
  </verify>
  <done>
ChipBarView uses `Set<PersistentIdentifier>` multi-select with toggle tap. PanelContentView manages `selectedLabelIDs` state, passes it to ChipBarView and FilteredCardListView, and includes stable sorted string in `.id()` for view recreation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement hybrid label filtering, title search, and drag-drop append</name>
  <files>
    Pastel/Views/Panel/FilteredCardListView.swift
  </files>
  <action>
**FilteredCardListView.swift -- major changes to init, body, and drop handlers:**

1. **Change init signature:** Replace `selectedLabelID: PersistentIdentifier?` with `selectedLabelIDs: Set<PersistentIdentifier>`. Store it as a property:
   ```swift
   private let selectedLabelIDs: Set<PersistentIdentifier>
   ```

2. **Simplify the @Query predicate to text-search only.** Remove ALL label filtering from the predicate (per RESEARCH.md: `#Predicate` CANNOT use `.contains()` on to-many relationships -- it crashes at runtime).

   New predicate logic in init:
   ```swift
   let predicate: Predicate<ClipboardItem>
   if !searchText.isEmpty {
       let search = searchText
       predicate = #Predicate<ClipboardItem> { item in
           item.textContent?.localizedStandardContains(search) == true ||
           item.sourceAppName?.localizedStandardContains(search) == true ||
           item.title?.localizedStandardContains(search) == true
       }
   } else {
       predicate = #Predicate<ClipboardItem> { _ in true }
   }
   ```
   **Critical:** Use `item.title?.localizedStandardContains(search) == true` pattern (not `??` or `!`). This is the project's established pattern for optional string methods in predicates (see MEMORY.md).

3. **Add in-memory label filtering** as a computed property:
   ```swift
   /// Items filtered by selected labels (in-memory, OR logic).
   /// If no labels selected, returns all items from @Query.
   private var filteredItems: [ClipboardItem] {
       guard !selectedLabelIDs.isEmpty else { return items }
       return items.filter { item in
           item.labels.contains { label in
               selectedLabelIDs.contains(label.persistentModelID)
           }
       }
   }
   ```

4. **Replace ALL usages of `items` in the body with `filteredItems`.** This includes:
   - `if items.isEmpty` -> `if filteredItems.isEmpty`
   - `ForEach(Array(items.enumerated()), ...)` -> `ForEach(Array(filteredItems.enumerated()), ...)`
   - `guard index < items.count` -> `guard index < filteredItems.count`
   - `let item = items[index]` -> `let item = filteredItems[index]`
   - `items.count` in moveSelection -> `filteredItems.count`
   - Quick paste `onKeyPress` handler: `guard index < items.count` -> `guard index < filteredItems.count`, `let item = items[index]` -> `let item = filteredItems[index]`

5. **Update drag-drop handlers** (both horizontal and vertical layout blocks). Change from single-label replace to multi-label append with duplicate check:

   Old:
   ```swift
   item.label = label
   ```

   New:
   ```swift
   // Append label (don't replace). Skip if already assigned.
   guard !item.labels.contains(where: {
       $0.persistentModelID == label.persistentModelID
   }) else { return true }
   item.labels.append(label)
   ```

   Full updated drop handler (applied to BOTH horizontal and vertical ForEach blocks):
   ```swift
   .dropDestination(for: String.self) { strings, _ in
       guard let encodedID = strings.first,
             let labelID = PersistentIdentifier.fromTransferString(encodedID),
             let label = try? modelContext.model(for: labelID) as? Label else {
           return false
       }
       // Append label if not already assigned (per CONTEXT.md: drag-drop = append)
       guard !item.labels.contains(where: {
           $0.persistentModelID == label.persistentModelID
       }) else { return true }
       item.labels.append(label)
       try? modelContext.save()
       return true
   } isTargeted: { targeted in
       withAnimation(.easeInOut(duration: 0.15)) {
           dropTargetIndex = targeted ? index : nil
       }
   }
   ```

6. **Update init to store selectedLabelIDs:**
   ```swift
   init(
       searchText: String,
       selectedLabelIDs: Set<PersistentIdentifier>,  // Changed parameter
       selectedIndex: Binding<Int?>,
       isShiftHeld: Bool = false,
       onPaste: @escaping (ClipboardItem) -> Void,
       onPastePlainText: @escaping (ClipboardItem) -> Void,
       onTypeToSearch: ((Character) -> Void)? = nil
   ) {
       self.selectedLabelIDs = selectedLabelIDs  // Store for in-memory filtering
       // ... predicate setup (text-only, no label) ...
       // ... rest of init unchanged ...
   }
   ```
  </action>
  <verify>
Build succeeds. Test the following scenarios mentally/via build:
1. Empty search + no labels = all items shown
2. Search "test" = items matching "test" in text, app name, or title
3. Select one label = items with that label
4. Select two labels = items with EITHER label (OR logic)
5. Search + labels = text matches filtered further by labels
6. Drag label onto card = label appended (not replaced), duplicate drag is no-op
  </verify>
  <done>
FilteredCardListView uses text-only #Predicate with title search, in-memory post-filtering for multi-label OR logic, and drag-drop appends labels with duplicate protection. All references to `items` replaced with `filteredItems` throughout the body.
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild -project Pastel.xcodeproj -scheme Pastel build` succeeds
2. ChipBarView allows multi-select (multiple chips with accent border)
3. FilteredCardListView filters by text (predicate) and labels (in-memory) separately
4. Search predicate includes `item.title?.localizedStandardContains(search) == true`
5. `.id()` modifier on FilteredCardListView includes sorted label IDs as string
6. Drag-drop appends labels, never replaces
7. Empty label selection shows all items
8. Multi-label selection uses OR logic
</verification>

<success_criteria>
- Multi-label chip bar filtering works with OR logic
- Search finds items by title, text content, and app name
- Drag-drop label assignment appends instead of replacing
- View recreation happens correctly when label selection or search changes
- No #Predicate crashes (label filtering is purely in-memory)
</success_criteria>

<output>
After completion, create `.planning/phases/11-item-titles-multi-label-edit-modal/11-03-SUMMARY.md`
</output>
