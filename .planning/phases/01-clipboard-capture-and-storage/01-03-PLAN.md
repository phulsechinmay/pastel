---
phase: 01-clipboard-capture-and-storage
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - Pastel/Services/ImageStorageService.swift
  - Pastel/Extensions/NSImage+Thumbnail.swift
  - Pastel/Services/ExpirationService.swift
  - Pastel/Services/ClipboardMonitor.swift
  - Pastel/App/AppState.swift
  - Pastel/PastelApp.swift
autonomous: false

must_haves:
  truths:
    - "User copies an image and a full-size PNG is saved to ~/Library/Application Support/Pastel/images/"
    - "User copies an image and a 200px-wide thumbnail PNG is saved alongside the full image"
    - "User copies an image and the ClipboardItem in SwiftData stores the image file path, not image data"
    - "User copies a password from 1Password (concealed type) and it auto-expires from history after 60 seconds"
    - "Status popover item count increments when an image is copied"
    - "App captures all content types end-to-end: text, rich text, URL, file, AND image"
  artifacts:
    - path: "Pastel/Services/ImageStorageService.swift"
      provides: "Disk-based image storage with thumbnail generation on background queue"
      contains: "ImageStorageService"
    - path: "Pastel/Extensions/NSImage+Thumbnail.swift"
      provides: "CGImageSource-based fast thumbnail generation"
      contains: "CGImageSourceCreateThumbnailAtIndex"
    - path: "Pastel/Services/ExpirationService.swift"
      provides: "Auto-expiration of concealed clipboard items after 60 seconds"
      contains: "ExpirationService"
  key_links:
    - from: "Pastel/Services/ClipboardMonitor.swift"
      to: "Pastel/Services/ImageStorageService.swift"
      via: "ClipboardMonitor calls ImageStorageService.saveImage on image capture"
      pattern: "saveImage"
    - from: "Pastel/Services/ImageStorageService.swift"
      to: "Pastel/Extensions/NSImage+Thumbnail.swift"
      via: "Uses CGImageSource thumbnail generation"
      pattern: "thumbnail"
    - from: "Pastel/Services/ClipboardMonitor.swift"
      to: "Pastel/Services/ExpirationService.swift"
      via: "Schedules expiration for concealed items after insert"
      pattern: "scheduleExpiration"
    - from: "Pastel/Services/ExpirationService.swift"
      to: "Pastel/Models/ClipboardItem.swift"
      via: "Deletes expired ClipboardItem from SwiftData and associated images from disk"
      pattern: "delete.*ClipboardItem"
---

<objective>
Implement image storage on disk with thumbnail generation, concealed item auto-expiration, and complete the end-to-end clipboard capture pipeline for all content types.

Purpose: This plan completes Phase 1 by adding the two remaining capabilities: (1) image capture with disk-based storage and thumbnail generation, fulfilling CLIP-02 and INFR-04, and (2) concealed item handling for password manager content. After this plan, Pastel silently captures ALL clipboard content types, persists everything across restarts, deduplicates, and respects password manager conventions.

Output: Complete Phase 1 functionality -- all content types captured, images stored as PNGs on disk with thumbnails, concealed items auto-expire, status popover shows accurate counts, everything persists across restart.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-clipboard-capture-and-storage/01-CONTEXT.md
@.planning/phases/01-clipboard-capture-and-storage/01-RESEARCH.md
@.planning/phases/01-clipboard-capture-and-storage/01-01-SUMMARY.md
@.planning/phases/01-clipboard-capture-and-storage/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ImageStorageService and NSImage+Thumbnail extension</name>
  <files>
    Pastel/Services/ImageStorageService.swift
    Pastel/Extensions/NSImage+Thumbnail.swift
  </files>
  <action>
    **1. NSImage+Thumbnail.swift** -- Fast thumbnail generation using CGImageSource (40x faster than NSImage resize per research).

    ```swift
    import ImageIO
    import AppKit

    extension NSImage {
        /// Generate a thumbnail using CGImageSource.
        /// maxPixelSize is the maximum dimension (width or height) of the output.
        static func thumbnail(from imageData: Data, maxPixelSize: Int = 200) -> NSImage? {
            let options: [CFString: Any] = [
                kCGImageSourceCreateThumbnailFromImageAlways: true,
                kCGImageSourceCreateThumbnailWithTransform: true,
                kCGImageSourceThumbnailMaxPixelSize: maxPixelSize
            ]
            guard let source = CGImageSourceCreateWithData(imageData as CFData, nil),
                  let cgImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary)
            else { return nil }
            return NSImage(cgImage: cgImage, size: NSSize(width: cgImage.width, height: cgImage.height))
        }
    }
    ```

    **2. ImageStorageService.swift** -- Disk-based image storage with background processing.

    Key design from research and CONTEXT.md:
    - Storage location: `~/Library/Application Support/Pastel/images/` (created on first use)
    - Full images: PNG format, capped at 4K resolution (3840px max dimension), downscale larger
    - Thumbnails: 200px wide, PNG format, filename pattern: `{UUID}_thumb.png`
    - Full images: filename pattern: `{UUID}.png`
    - All disk I/O on a dedicated serial DispatchQueue at .utility QoS
    - Database stores only filenames (not full paths) -- paths are resolved at runtime

    Implementation:

    a) **Properties:**
    - `static let shared = ImageStorageService()` (singleton)
    - `private let fileManager = FileManager.default`
    - `private let imagesDirectory: URL` (computed in init)
    - `private let backgroundQueue = DispatchQueue(label: "app.pastel.imageStorage", qos: .utility)` (serial)

    b) **init():**
    - Compute imagesDirectory: `FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!` / "Pastel" / "images"
    - Create directory with intermediates if it doesn't exist
    - Use try? (don't crash if directory already exists)

    c) **saveImage(data: Data, completion: @escaping (String?, String?) -> Void):**
    - Dispatch to backgroundQueue
    - Generate UUID string for filenames
    - Downscale if needed: check image dimensions via CGImageSourceCopyPropertiesAtIndex. If max(width, height) > 3840, use CGImageSourceCreateThumbnailAtIndex with maxPixelSize 3840 to create a downscaled version. Convert back to PNG Data via NSBitmapImageRep.
    - Save full image as `{UUID}.png` to imagesDirectory
    - Generate thumbnail: call NSImage.thumbnail(from:maxPixelSize:) with 200
    - Convert thumbnail NSImage to PNG Data: tiffRepresentation -> NSBitmapImageRep -> representation(using: .png)
    - Save thumbnail as `{UUID}_thumb.png` to imagesDirectory
    - Dispatch back to main queue: call completion(imageFileName, thumbnailFileName)
    - If any step fails, call completion(nil, nil)

    d) **deleteImage(imagePath: String?, thumbnailPath: String?):**
    - Dispatch to backgroundQueue
    - Remove files from imagesDirectory if paths are non-nil
    - Use try? (don't crash on missing files)

    e) **resolveImageURL(_ filename: String) -> URL:**
    - Returns imagesDirectory.appendingPathComponent(filename)
    - Public method for views to load images by filename

    f) **computeImageHash(data: Data) -> String:**
    - Hash first 4096 bytes of image data for speed (from research -- full hash too slow for large images)
    - Use SHA256 from CryptoKit
    - Return hex string

    **Critical: NSPasteboard is NOT thread-safe.** Image data must be read from pasteboard on the main thread BEFORE dispatching to the background queue. The ClipboardMonitor reads the raw Data on main thread, then passes it to ImageStorageService which processes on background.
  </action>
  <verify>
    Build: `xcodebuild build -project Pastel.xcodeproj -scheme Pastel -destination 'platform=macOS' 2>&1 | tail -20`
    Expected: BUILD SUCCEEDED.
    Verify directory would be created correctly: The path logic for ~/Library/Application Support/Pastel/images/ is standard and verified by the FileManager API.
  </verify>
  <done>
    ImageStorageService compiles, uses a background serial queue for all disk I/O, generates thumbnails at 200px via CGImageSource, downscales images larger than 4K, saves as PNG with UUID filenames, and provides cleanup/resolve methods. NSImage+Thumbnail extension compiles and uses CGImageSourceCreateThumbnailAtIndex.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ExpirationService, wire image capture into ClipboardMonitor, and complete pipeline</name>
  <files>
    Pastel/Services/ExpirationService.swift
    Pastel/Services/ClipboardMonitor.swift
    Pastel/App/AppState.swift
    Pastel/PastelApp.swift
  </files>
  <action>
    **1. ExpirationService.swift** -- Auto-expire concealed clipboard items after 60 seconds.

    Create a class ExpirationService:
    - `private var modelContext: ModelContext` (injected via init)
    - `private var pendingExpirations: [PersistentModelID: DispatchWorkItem] = [:]` (track pending deletions to cancel if item is manually deleted)

    - **init(modelContext: ModelContext):** Store context.

    - **scheduleExpiration(for item: ClipboardItem):**
      - Guard item.isConcealed == true
      - Create a DispatchWorkItem that:
        - Fetches the item by its persistentModelID from modelContext (it may have been deleted already)
        - If found: delete from modelContext, save, then call ImageStorageService.shared.deleteImage if it had image paths
        - Remove from pendingExpirations
      - Store in pendingExpirations keyed by item.persistentModelID
      - Schedule: DispatchQueue.main.asyncAfter(deadline: .now() + 60, execute: workItem)
      - Note: Use main queue because SwiftData modelContext is main-thread only in Phase 1

    - **expireOverdueItems():** (call on app launch)
      - Fetch all ClipboardItems where isConcealed == true AND expiresAt is before Date.now
      - Delete them from modelContext
      - Save

    - **cancelExpiration(for itemID: PersistentModelID):**
      - Cancel and remove the DispatchWorkItem from pendingExpirations

    **2. Update ClipboardMonitor.swift** -- Add image capture handling.

    In the processPasteboardContent() method, add the .image case:

    a) When content type is .image:
    - Read image data from pasteboard on main thread:
      ```swift
      guard let imageData = pasteboard.data(forType: .tiff) ?? pasteboard.data(forType: .png) else { return }
      ```
    - Compute content hash using ImageStorageService.computeImageHash(data:) (first 4KB of image data)
    - Check consecutive duplicate (same as text -- compare hash with most recent item)
    - If not duplicate:
      - Capture source app info
      - Call ImageStorageService.shared.saveImage(data: imageData) with completion handler
      - In the completion handler (back on main thread):
        - Create ClipboardItem with contentType "image", imagePath, thumbnailPath from completion
        - textContent = nil, htmlContent = nil, rtfData = nil
        - byteCount = imageData.count
        - characterCount = 0
        - Set isConcealed and expiresAt as appropriate
        - Insert into modelContext
        - modelContext.save()
        - Increment itemCount
        - If isConcealed: call expirationService.scheduleExpiration(for: newItem)

    b) For ALL content types (text, richText, url, file) -- also wire expiration:
    - After inserting a concealed item, call expirationService.scheduleExpiration(for: newItem)
    - This was missing from Plan 01-02's implementation -- add it now

    c) Add expirationService as a property of ClipboardMonitor:
    - `private var expirationService: ExpirationService`
    - Initialize in ClipboardMonitor.init alongside modelContext

    **3. Update AppState.swift:**
    - No major changes needed -- ClipboardMonitor already exposes itemCount
    - Ensure the ExpirationService is accessible if needed for future cleanup

    **4. Update PastelApp.swift:**
    - In the init, after creating AppState and setting up ClipboardMonitor:
      - Call expirationService.expireOverdueItems() to clean up any concealed items that expired while the app was not running

    **5. Handle the image capture async flow carefully:**
    - Read pasteboard data (main thread) -> dispatch to background for disk I/O -> callback on main thread for SwiftData insert
    - The item count increments AFTER the completion handler fires (when the item is actually persisted)
    - This is intentionally different from Plan 01-02's synchronous text/URL/file capture where itemCount increments immediately. For images, the async completion ensures the item is actually saved before counting it. Both paths increment on the main thread, so @Observable updates are consistent for the UI.
    - If image save fails (completion returns nil, nil), still create the ClipboardItem but with nil image/thumbnail paths (metadata-only entry -- better than losing the event entirely)

    **Testing notes for the checkpoint:**
    - Copy text -> captured (from Plan 01-02, should still work)
    - Copy an image (e.g., screenshot with Cmd+Shift+4, then open in Preview and Cmd+C) -> item count increments, PNG file appears in ~/Library/Application Support/Pastel/images/, thumbnail file appears alongside
    - Copy a URL -> classified as URL type
    - Copy same image twice -> only one entry (dedup via hash of first 4KB)
    - If testing concealed type: Copy from 1Password -> should appear, then disappear after 60 seconds
  </action>
  <verify>
    Build: `xcodebuild build -project Pastel.xcodeproj -scheme Pastel -destination 'platform=macOS' 2>&1 | tail -20`
    Expected: BUILD SUCCEEDED.

    After running the app, verify:
    1. Copy an image -> check `ls ~/Library/Application\ Support/Pastel/images/` shows UUID.png and UUID_thumb.png files
    2. The thumbnail file should be significantly smaller than the full image
    3. Item count in popover increments after image copy
  </verify>
  <done>
    Image capture works end-to-end: pasteboard image data is read on main thread, saved to disk as PNG on background queue, thumbnail generated at 200px, ClipboardItem created with file path references (not image data), and item count increments. ExpirationService deletes concealed items after 60 seconds. All five content types (text, richText, url, file, image) are captured correctly.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Phase 1 clipboard capture and storage system. The app:
    1. Runs in the menu bar with a clipboard icon (no dock icon)
    2. Captures text, rich text, URLs, file references, and images from the system clipboard
    3. Classifies each clipboard change by content type (priority: image > URL > file > richText > text)
    4. Deduplicates consecutive identical copies
    5. Stores images as PNG files on disk with 200px thumbnails
    6. Persists all clipboard history to SwiftData
    7. Auto-expires concealed items (from password managers) after 60 seconds
    8. Shows item count and monitoring toggle in the status popover
  </what-built>
  <how-to-verify>
    Build and run the app, then test each scenario:

    1. **Menu bar presence (INFR-01):**
       - Verify clipboard icon appears in the menu bar
       - Verify NO dock icon appears
       - Click the icon -- popover should open with item count, monitoring toggle, quit button

    2. **Text capture (CLIP-01):**
       - Open TextEdit or any app, select text, Cmd+C
       - Click menu bar icon -- item count should increment by 1

    3. **URL capture (CLIP-03):**
       - Copy a URL like "https://apple.com" from Safari's address bar or any text field
       - Item count should increment

    4. **File capture (CLIP-04):**
       - In Finder, select a file and press Cmd+C
       - Item count should increment

    5. **Image capture (CLIP-02, INFR-04):**
       - Take a screenshot (Cmd+Shift+4, select area), open in Preview, Cmd+A, Cmd+C
       - OR copy an image from a webpage
       - Item count should increment
       - Check: `ls ~/Library/Application\ Support/Pastel/images/` in Terminal
       - Should see UUID.png (full image) and UUID_thumb.png (thumbnail) files
       - Thumbnail file should be much smaller than full image

    6. **Consecutive dedup (CLIP-06):**
       - Copy the same text twice in a row
       - Item count should increment only once (not twice)

    7. **Persistence (CLIP-05):**
       - Note the current item count
       - Click "Quit Pastel" in popover
       - Relaunch the app
       - Item count should be the same as before quit

    8. **Monitoring toggle:**
       - Toggle monitoring OFF in popover
       - Copy some text -- item count should NOT change
       - Toggle monitoring ON
       - Copy new text -- item count should increment

    If any of these fail, describe which test and what happened.
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe which tests failed and what you observed.</resume-signal>
</task>

</tasks>

<verification>
Phase 1 success criteria (from ROADMAP.md):
1. User copies text in any app and it appears in stored clipboard history -- verified by item count increment
2. User copies an image and a thumbnail is saved to disk (not in the database) -- verified by checking ~/Library/Application Support/Pastel/images/
3. User copies a URL or file reference and it is captured as the correct content type -- verified by copying URLs and files
4. User quits and relaunches the app and all previous clipboard history is still present -- verified by quit/relaunch test
5. User copies the same text twice consecutively and only one entry appears in history -- verified by dedup test
</verification>

<success_criteria>
- ALL five content types captured: text, richText, URL, file, image
- Images saved to disk as PNG with UUID filenames in ~/Library/Application Support/Pastel/images/
- Thumbnails generated at 200px width alongside full images
- Concealed items (password managers) auto-expire after 60 seconds
- ClipboardItem in SwiftData stores file path references for images, never image data
- Consecutive duplicates detected and skipped
- Data persists across app restart
- Status popover shows accurate item count and working monitoring toggle
- All Phase 1 requirements addressed: CLIP-01, CLIP-02, CLIP-03, CLIP-04, CLIP-05, CLIP-06, INFR-01, INFR-04
</success_criteria>

<output>
After completion, create `.planning/phases/01-clipboard-capture-and-storage/01-03-SUMMARY.md`
</output>
