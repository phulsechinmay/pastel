---
phase: 01-clipboard-capture-and-storage
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - Pastel/Services/ClipboardMonitor.swift
  - Pastel/Extensions/NSPasteboard+Reading.swift
  - Pastel/App/AppState.swift
  - Pastel/PastelApp.swift
  - Pastel/Views/MenuBar/StatusPopoverView.swift
autonomous: true

must_haves:
  truths:
    - "User copies text in any app and it appears in stored clipboard history"
    - "User copies a URL and it is classified as content type 'url'"
    - "User copies a file reference and it is classified as content type 'file'"
    - "User copies the same text twice consecutively and only one entry appears in history"
    - "User quits and relaunches the app and all previous clipboard items are still present"
    - "Status popover shows the correct, incrementing item count after each copy"
  artifacts:
    - path: "Pastel/Services/ClipboardMonitor.swift"
      provides: "Timer-based NSPasteboard polling, content reading, dedup, and SwiftData persistence"
      contains: "ClipboardMonitor"
    - path: "Pastel/Extensions/NSPasteboard+Reading.swift"
      provides: "Content type classification and typed pasteboard reading helpers"
      contains: "classifyContent"
  key_links:
    - from: "Pastel/Services/ClipboardMonitor.swift"
      to: "Pastel/Models/ClipboardItem.swift"
      via: "Creates and persists ClipboardItem instances to SwiftData"
      pattern: "ClipboardItem\\("
    - from: "Pastel/Services/ClipboardMonitor.swift"
      to: "Pastel/Extensions/NSPasteboard+Reading.swift"
      via: "Uses classifyContent() for type detection"
      pattern: "classifyContent"
    - from: "Pastel/PastelApp.swift"
      to: "Pastel/Services/ClipboardMonitor.swift"
      via: "AppState creates and starts ClipboardMonitor"
      pattern: "ClipboardMonitor"
    - from: "Pastel/Services/ClipboardMonitor.swift"
      to: "Pastel/App/AppState.swift"
      via: "Updates itemCount after each capture"
      pattern: "itemCount"
---

<objective>
Implement the clipboard monitoring service that polls NSPasteboard, classifies content types, deduplicates consecutive copies, and persists clipboard items to SwiftData.

Purpose: This is the core capture engine of Pastel. Without it, the app is an empty shell. This plan delivers the ability to silently capture everything the user copies -- text, URLs, file references, and rich text -- classify each item by type, detect and skip consecutive duplicates, and persist items to the SwiftData store. It also wires the monitor into the app lifecycle and updates the status popover's item count.

Output: A running app that actively captures clipboard changes, persists them to disk via SwiftData, and displays the count in the menu bar popover. Text, URL, file, and rich text content types all captured correctly. Image capture is deferred to Plan 01-03.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-clipboard-capture-and-storage/01-CONTEXT.md
@.planning/phases/01-clipboard-capture-and-storage/01-RESEARCH.md
@.planning/phases/01-clipboard-capture-and-storage/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NSPasteboard+Reading extension and ClipboardMonitor service</name>
  <files>
    Pastel/Extensions/NSPasteboard+Reading.swift
    Pastel/Services/ClipboardMonitor.swift
  </files>
  <action>
    **1. NSPasteboard+Reading.swift** -- Typed pasteboard reading helpers and content classification.

    Create an extension on NSPasteboard with:

    a) **Custom PasteboardType constants** for concealed/transient types:
    ```swift
    extension NSPasteboard.PasteboardType {
        static let concealed = NSPasteboard.PasteboardType("org.nspasteboard.ConcealedType")
        static let transient = NSPasteboard.PasteboardType("org.nspasteboard.TransientType")
        static let autoGenerated = NSPasteboard.PasteboardType("org.nspasteboard.AutoGeneratedType")
    }
    ```

    b) **classifyContent() -> (ContentType, isConcealed: Bool)?** method:
    - Returns nil if pasteboard is empty, transient, or auto-generated (skip entirely)
    - Checks for concealed type marker (from password managers) -- still capture but flag isConcealed=true
    - Priority classification (from research Pattern 2):
      - .tiff or .png present -> .image
      - .fileURL present -> check if URL scheme is http/https -> .url, otherwise .file
      - .URL present -> .url
      - .string present -> check if string is a valid http/https URL -> .url, then check for .rtf or .html -> .richText, else .text
    - Return the classified ContentType and whether it's concealed

    c) **readTextContent() -> (text: String?, html: String?, rtfData: Data?, byteCount: Int)** method:
    - Read string(forType: .string) for plain text
    - Read string(forType: .html) for HTML content (optional)
    - Read data(forType: .rtf) for RTF data (optional)
    - Calculate byteCount from the largest representation
    - Store BOTH plain text and rich text per research recommendation for paste-back fidelity

    d) **readURLContent() -> (urlString: String?, byteCount: Int)** method:
    - Read from .URL type first, then fall back to .string
    - Validate it's actually an http/https URL
    - Return the URL string

    e) **readFileContent() -> (filePath: String?, byteCount: Int)** method:
    - Read from .fileURL type
    - Return the file URL's path string

    **2. ClipboardMonitor.swift** -- The core polling service.

    Create an @Observable class ClipboardMonitor with:

    a) **Properties:**
    - `var isMonitoring: Bool = true` (observable for UI binding)
    - `var itemCount: Int = 0` (observable for popover display)
    - `var skipNextChange: Bool = false` (for future self-paste loop prevention in Phase 3)
    - `private var timer: Timer?`
    - `private var lastChangeCount: Int = 0`
    - `private let pasteboard = NSPasteboard.general`
    - `private var modelContext: ModelContext` (injected via init)

    b) **init(modelContext: ModelContext)**:
    - Store the modelContext
    - Load initial itemCount from SwiftData: fetch count of all ClipboardItem records using FetchDescriptor
    - Set lastChangeCount = pasteboard.changeCount

    c) **start():**
    - Set lastChangeCount = pasteboard.changeCount (re-sync on start)
    - Create Timer.scheduledTimer with interval 0.5, repeats true
    - Set timer.tolerance = 0.1 (energy efficiency per research)
    - Timer callback calls checkForChanges()

    d) **stop():**
    - timer?.invalidate()
    - timer = nil

    e) **toggleMonitoring():**
    - Toggle isMonitoring
    - If now true: start(). If now false: stop()

    f) **checkForChanges() (private):**
    - Guard isMonitoring is true
    - Read pasteboard.changeCount
    - Guard it differs from lastChangeCount
    - Update lastChangeCount
    - If skipNextChange is true: reset it and return (Phase 3 self-paste prevention)
    - Call processPasteboardContent()

    g) **processPasteboardContent() (private):**
    - Call pasteboard.classifyContent() to get (ContentType, isConcealed)
    - If nil (empty, transient, auto-generated): return early
    - Based on content type, read the appropriate content:
      - .text, .richText: readTextContent()
      - .url: readURLContent()
      - .file: readFileContent()
      - .image: FOR NOW, just log "Image capture deferred to Plan 01-03" and return (image handling comes in Plan 01-03)
    - Capture source app: NSWorkspace.shared.frontmostApplication -> bundleIdentifier, localizedName
    - Compute content hash using SHA256 (import CryptoKit):
      - Hash the primary content (text string, URL string, or file path)
      - Use `SHA256.hash(data: Data(content.utf8))` and convert to hex string
    - **Consecutive duplicate check:** Fetch the most recent ClipboardItem (FetchDescriptor with sortBy timestamp descending, fetchLimit 1). If its contentHash matches the new hash, skip (return early). This is CONSECUTIVE dedup only -- same content from different times is fine.
    - Create a new ClipboardItem with all fields populated:
      - textContent, htmlContent, rtfData as read
      - contentType: the classified type's rawValue
      - timestamp: Date.now
      - sourceAppBundleID, sourceAppName from frontmost app
      - characterCount: textContent?.count ?? 0
      - byteCount: from the read method
      - changeCount: pasteboard.changeCount
      - imagePath: nil (for now)
      - thumbnailPath: nil (for now)
      - isConcealed: from classification
      - expiresAt: if isConcealed, Date.now + 60 seconds, else nil (NOTE: expiresAt is SET here but ExpirationService that DELETES expired items is implemented in Plan 01-03)
      - contentHash: computed hash
    - Insert into modelContext
    - Call modelContext.save() explicitly (do NOT rely on autosave -- research finding: data loss is unacceptable for a clipboard manager)
    - Increment itemCount

    **Critical implementation notes:**
    - ALL pasteboard reading happens on the main thread (NSPasteboard is NOT thread-safe)
    - Timer fires on main run loop (default behavior of Timer.scheduledTimer) -- this is correct
    - Read pasteboard content IMMEDIATELY in the same callback that detects the change (content can change before next poll)
    - Use do/try/catch around modelContext.save() and log errors
    - The @Attribute(.unique) on contentHash will cause a SwiftData merge conflict if a non-consecutive duplicate is inserted -- handle this gracefully (catch the error and skip, or use a different dedup strategy if @Attribute(.unique) causes issues)
  </action>
  <verify>
    Build: `xcodebuild build -project Pastel.xcodeproj -scheme Pastel -destination 'platform=macOS' 2>&1 | tail -20`
    Expected: BUILD SUCCEEDED with zero errors.
  </verify>
  <done>
    ClipboardMonitor.swift and NSPasteboard+Reading.swift compile without errors. ClipboardMonitor has timer-based polling at 0.5s, content type classification, consecutive duplicate detection via SHA256 hash comparison, source app capture, and SwiftData persistence with explicit save.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire ClipboardMonitor into app lifecycle and update status popover</name>
  <files>
    Pastel/App/AppState.swift
    Pastel/PastelApp.swift
    Pastel/Views/MenuBar/StatusPopoverView.swift
  </files>
  <action>
    Connect the ClipboardMonitor to the app so it starts on launch and the popover reflects live state.

    **1. Update AppState.swift:**
    - Add a `clipboardMonitor: ClipboardMonitor?` property (optional because it needs ModelContext from SwiftData)
    - Add a `func setup(modelContext: ModelContext)` method that:
      - Creates ClipboardMonitor(modelContext: modelContext)
      - Starts monitoring: clipboardMonitor?.start()
      - Stores it in the property
    - Add computed property `var itemCount: Int` that returns clipboardMonitor?.itemCount ?? 0
    - Add computed property `var isMonitoring: Bool` that returns clipboardMonitor?.isMonitoring ?? false

    **2. Update PastelApp.swift:**
    - The challenge: MenuBarExtra needs to pass the SwiftData modelContext to AppState.
    - Approach: Use .modelContainer(for: ClipboardItem.self) on the scene, and use an initializer or onAppear in StatusPopoverView to set up the monitor.
    - Alternative approach (simpler): Create the ModelContainer manually in PastelApp init, store it as a property, and pass the mainContext to AppState.setup():
      ```swift
      @main
      struct PastelApp: App {
          let modelContainer: ModelContainer
          @State private var appState: AppState

          init() {
              let container = try! ModelContainer(for: ClipboardItem.self)
              self.modelContainer = container
              let state = AppState()
              state.setup(modelContext: container.mainContext)
              self._appState = State(initialValue: state)
          }

          var body: some Scene {
              MenuBarExtra {
                  StatusPopoverView()
                      .environment(appState)
                      .modelContainer(modelContainer)
                      .frame(width: 260, height: 160)
              } label: {
                  Image(systemName: "clipboard")
              }
              .menuBarExtraStyle(.window)
          }
      }
      ```
    - This ensures ClipboardMonitor starts immediately on app launch and has access to the SwiftData context.

    **3. Update StatusPopoverView.swift:**
    - Bind the monitoring toggle to appState.clipboardMonitor?.toggleMonitoring()
    - Display appState.itemCount (which reads from clipboardMonitor.itemCount)
    - The count should update reactively because ClipboardMonitor is @Observable and itemCount is an observable property
    - Ensure the toggle reflects the actual monitoring state (on/off)
    - Wire it like:
      ```swift
      Toggle("Monitoring", isOn: Binding(
          get: { appState.clipboardMonitor?.isMonitoring ?? false },
          set: { _ in appState.clipboardMonitor?.toggleMonitoring() }
      ))
      ```

    **4. System sleep handling:**
    - In ClipboardMonitor, observe NSWorkspace.didWakeNotification
    - On wake, re-read pasteboard.changeCount and process if it differs from lastChangeCount
    - This handles clipboard changes that occurred during sleep
    - Add in start(): `NSWorkspace.shared.notificationCenter.addObserver(forName: NSWorkspace.didWakeNotification, ...)`
    - In the observer callback: call checkForChanges()

    **Testing approach after wiring:**
    - Build and run the app
    - Copy some text in any app (e.g., Terminal, Safari)
    - Check that the popover's item count increments
    - Copy the same text again -- count should NOT increment (dedup working)
    - Copy different text -- count should increment
    - Quit and relaunch -- count should persist (SwiftData working)
  </action>
  <verify>
    Build: `xcodebuild build -project Pastel.xcodeproj -scheme Pastel -destination 'platform=macOS' 2>&1 | tail -20`
    Expected: BUILD SUCCEEDED.

    Functional test (manual after build):
    1. Run the app
    2. Copy text in any app
    3. Click menu bar icon -- popover should show "1 items captured" (or more if prior items existed)
    4. Copy the same text again -- count should NOT change
    5. Copy different text -- count should increment
    6. Toggle monitoring off, copy text, count should NOT change
    7. Toggle monitoring on, copy new text, count should increment
    8. Quit app, relaunch, count should persist
  </verify>
  <done>
    ClipboardMonitor starts automatically on app launch. Copying text in any app increments the item count in the status popover. Consecutive duplicate text is not captured twice. Toggling monitoring pauses/resumes capture. Item count persists across app restart (SwiftData persistence confirmed). System wake re-checks clipboard.
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild build` succeeds with zero errors
2. App launches and clipboard icon appears in menu bar
3. Copy plain text -> item count increments in popover
4. Copy a URL (e.g., "https://example.com") -> captured (count increments)
5. Copy a file in Finder (Cmd+C on a file) -> captured
6. Copy same text twice -> count increments only once (dedup)
7. Toggle monitoring off -> copies are not captured
8. Quit and relaunch -> item count persists
9. Console shows no SwiftData errors
</verification>

<success_criteria>
- ClipboardMonitor polls at 0.5s and detects all clipboard changes
- Text, URL, file, and rich text content types are classified correctly
- Consecutive duplicates are detected and skipped
- Items persist to SwiftData with explicit save after each insert
- Source app (bundleID, name) is captured for each item
- Status popover shows live, accurate item count
- Monitoring toggle works (pause/resume)
- Data persists across app restart
- Requirements fully addressed: CLIP-01 (text), CLIP-03 (URLs), CLIP-04 (files), CLIP-05 (persistence), CLIP-06 (dedup)
- Requirements partially addressed: CLIP-02 (image classification detected but storage deferred to 01-03)
</success_criteria>

<output>
After completion, create `.planning/phases/01-clipboard-capture-and-storage/01-02-SUMMARY.md`
</output>
