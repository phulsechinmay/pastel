---
phase: 04-organization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Pastel/Models/Label.swift
  - Pastel/Models/ClipboardItem.swift
  - Pastel/PastelApp.swift
  - Pastel/Views/Panel/SearchFieldView.swift
  - Pastel/Views/Panel/FilteredCardListView.swift
  - Pastel/Views/Panel/PanelContentView.swift
autonomous: true

must_haves:
  truths:
    - "User types in search field and card list filters to matching items in real time"
    - "Search matches against textContent and sourceAppName"
    - "Empty search shows all items"
    - "No matching items shows empty state message"
  artifacts:
    - path: "Pastel/Models/Label.swift"
      provides: "Label SwiftData model with name, colorName, sortOrder"
      contains: "@Model"
    - path: "Pastel/Views/Panel/SearchFieldView.swift"
      provides: "Persistent search text field"
      contains: "TextField"
    - path: "Pastel/Views/Panel/FilteredCardListView.swift"
      provides: "Dynamic @Query child view with init-based predicate"
      contains: "_items = Query"
  key_links:
    - from: "Pastel/Views/Panel/PanelContentView.swift"
      to: "Pastel/Views/Panel/FilteredCardListView.swift"
      via: "passes debouncedSearchText and selectedLabelID to child init"
      pattern: "FilteredCardListView\\("
    - from: "Pastel/PastelApp.swift"
      to: "Pastel/Models/Label.swift"
      via: "ModelContainer registers Label.self"
      pattern: "Label\\.self"
---

<objective>
Create the Label data model, add search functionality to the panel, and restructure PanelContentView to use a dynamic @Query pattern via FilteredCardListView.

Purpose: This is the data foundation for all Phase 4 features. The Label model enables labeling/filtering. The FilteredCardListView with init-based @Query enables dynamic search and (later) label filtering. The search field gives users immediate value by finding items in their clipboard history.

Output: Label.swift model, SearchFieldView, FilteredCardListView with dynamic predicate, restructured PanelContentView with search field and debounced filtering.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-organization/04-CONTEXT.md
@.planning/phases/04-organization/04-RESEARCH.md

@Pastel/Models/ClipboardItem.swift
@Pastel/PastelApp.swift
@Pastel/Views/Panel/PanelContentView.swift
@Pastel/Views/Panel/ClipboardCardView.swift
@Pastel/Views/Panel/EmptyStateView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Label model + ClipboardItem relationship + ModelContainer registration</name>
  <files>
    Pastel/Models/Label.swift
    Pastel/Models/ClipboardItem.swift
    Pastel/PastelApp.swift
  </files>
  <action>
    1. Create `Pastel/Models/Label.swift`:
       - `@Model final class Label` with properties: `name: String`, `colorName: String`, `sortOrder: Int`
       - Inverse relationship: `@Relationship(deleteRule: .nullify, inverse: \ClipboardItem.label) var items: [ClipboardItem]`
       - Init accepting name, colorName, sortOrder. Initialize `items = []`.

    2. Add optional relationship to `ClipboardItem.swift`:
       - Add `var label: Label?` property (no default needed -- optional defaults to nil)
       - Place it after the existing `contentHash` property, before the `type` computed property
       - Do NOT modify the init -- SwiftData handles optional relationship properties without explicit init params

    3. Update `PastelApp.swift` ModelContainer:
       - Change `ModelContainer(for: ClipboardItem.self)` to `ModelContainer(for: ClipboardItem.self, Label.self)`
       - This is critical: SwiftData must know about Label at container creation time
       - Lightweight migration is automatic for adding a new model + optional relationship

    Anti-patterns to avoid:
    - Do NOT use `.cascade` delete rule on the relationship (use `.nullify` -- deleting a label should NOT delete its items)
    - Do NOT add `label` parameter to ClipboardItem.init -- it's optional and handled by SwiftData relationship management
  </action>
  <verify>
    `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild -scheme Pastel -destination 'platform=macOS' build 2>&1 | tail -5` -- must show BUILD SUCCEEDED
  </verify>
  <done>Label model exists with name/colorName/sortOrder/items. ClipboardItem has optional label relationship. ModelContainer registers both models. Build succeeds.</done>
</task>

<task type="auto">
  <name>Task 2: Search field + FilteredCardListView + PanelContentView restructure</name>
  <files>
    Pastel/Views/Panel/SearchFieldView.swift
    Pastel/Views/Panel/FilteredCardListView.swift
    Pastel/Views/Panel/PanelContentView.swift
  </files>
  <action>
    1. Create `Pastel/Views/Panel/SearchFieldView.swift`:
       - A simple view wrapping a `TextField("Search...", text: $searchText)` with a `@Binding var searchText: String`
       - Style: `.textFieldStyle(.plain)`, padding horizontal 12, vertical 8
       - Add a magnifying glass icon (SF Symbol `magnifyingglass`) leading, and a clear button (SF Symbol `xmark.circle.fill`) trailing that appears only when text is non-empty
       - Background: `Color.white.opacity(0.06)` with `RoundedRectangle(cornerRadius: 8)` -- consistent with existing card styling

    2. Create `Pastel/Views/Panel/FilteredCardListView.swift`:
       - Struct with `@Query private var items: [ClipboardItem]`
       - Init accepts `searchText: String` and `selectedLabelID: PersistentIdentifier?`
       - In init, construct predicate using the 4-case pattern from research:
         - No search + no label: `#Predicate<ClipboardItem> { _ in true }`
         - Search + no label: match `textContent?.localizedStandardContains(search) ?? false || sourceAppName?.localizedStandardContains(search) ?? false`
         - No search + label: match `label?.persistentModelID == labelID`
         - Search + label: both conditions ANDed
       - Assign `_items = Query(filter: predicate, sort: \ClipboardItem.timestamp, order: .reverse)`
       - Body: if items.isEmpty show "No matching items" text (centered, secondary style). Otherwise show the scrollable LazyVStack of ClipboardCardView cards.
       - IMPORTANT: `let search = searchText` -- capture searchText as a local `let` before using in `#Predicate` closure (required for macro expansion)
       - IMPORTANT: Use `?? false` for optional string method calls in predicate (not if-let)
       - Accept `selectedIndex: Binding<Int?>` and `onPaste: (ClipboardItem) -> Void` to preserve existing keyboard nav and paste behavior
       - Include the same onTapGesture(count: 2) for paste and onTapGesture(count: 1) for select as currently in PanelContentView
       - Include ScrollViewReader with onChange(of: selectedIndex) for scroll-to-selection behavior

    3. Restructure `PanelContentView.swift`:
       - Remove the `@Query` property -- filtering is now in FilteredCardListView
       - Add `@State private var searchText = ""`
       - Add `@State private var debouncedSearchText = ""`
       - Add `@State private var selectedLabel: Label? = nil` (for future chip bar use)
       - Keep `@State private var selectedIndex: Int? = nil`
       - Keep `@Environment(PanelActions.self) private var panelActions`
       - Layout the body as: Header -> Divider -> SearchFieldView -> FilteredCardListView
       - Pass `debouncedSearchText` and `selectedLabel?.persistentModelID` to FilteredCardListView
       - Add `.task(id: searchText)` debounce: `try? await Task.sleep(for: .milliseconds(200))`, then `guard !Task.isCancelled else { return }`, then `debouncedSearchText = searchText`
       - Keep all keyboard navigation (.onKeyPress for up/down/return) and .onAppear { selectedIndex = nil }
       - Keep .focusable(), .focusEffectDisabled(), .preferredColorScheme(.dark)
       - The pasteItem function stays in PanelContentView and is passed as a closure to FilteredCardListView

    Anti-patterns to avoid:
    - Do NOT use `lowercased()` in #Predicate -- crashes at runtime. Use `localizedStandardContains()`.
    - Do NOT compare Label objects directly in predicate -- compare `persistentModelID`
    - Do NOT use @Query directly in PanelContentView with changing state -- use the child view init pattern
  </action>
  <verify>
    `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild -scheme Pastel -destination 'platform=macOS' build 2>&1 | tail -5` -- must show BUILD SUCCEEDED
  </verify>
  <done>Search field appears below header in panel. Typing filters items in real time with ~200ms debounce. Empty search shows all items. No matches shows "No matching items" message. Keyboard navigation (arrows + Enter) and double-click paste still work. Selection highlight still works.</done>
</task>

</tasks>

<verification>
1. Build succeeds: `xcodebuild -scheme Pastel -destination 'platform=macOS' build`
2. Label.swift exists with @Model, name, colorName, sortOrder, items relationship
3. ClipboardItem.swift has `var label: Label?`
4. PastelApp.swift ModelContainer includes `Label.self`
5. PanelContentView no longer has @Query -- delegates to FilteredCardListView
6. FilteredCardListView constructs @Query in init with predicate
7. SearchFieldView renders a text field with magnifying glass and clear button
8. Debounce uses .task(id:) with 200ms sleep
</verification>

<success_criteria>
- Label SwiftData model created with correct relationship (nullify delete rule, inverse specified)
- Search field visible in panel below header
- Typing in search filters clipboard items by textContent and sourceAppName
- Debounce prevents query rebuild on every keystroke
- Empty results show "No matching items"
- All existing functionality preserved (keyboard nav, paste, selection)
- Build succeeds with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-organization/04-01-SUMMARY.md`
</output>
