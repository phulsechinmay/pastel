---
phase: 16-dragdrop
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - Pastel/Views/Panel/PanelController.swift
  - Pastel/Views/Panel/FilteredCardListView.swift
autonomous: true

must_haves:
  truths:
    - "Panel remains visible throughout the entire drag session (does not dismiss when cursor leaves panel bounds)"
    - "Dragging an item from the panel does not create a duplicate entry in clipboard history"
    - "Panel dismisses normally after drag session ends (click-outside and Escape still work)"
    - "Clipboard monitor resumes capturing after drag completes (no permanent pause)"
  artifacts:
    - path: "Pastel/Views/Panel/PanelController.swift"
      provides: "isDragging state that suppresses panel dismissal during drag"
      contains: "isDragging"
    - path: "Pastel/Views/Panel/FilteredCardListView.swift"
      provides: ".onDrag closure with side effects for drag state and monitor pause"
      contains: "isDragging"
  key_links:
    - from: "Pastel/Views/Panel/FilteredCardListView.swift"
      to: "Pastel/Views/Panel/PanelController.swift"
      via: "Sets panelController.isDragging = true on drag start"
      pattern: "isDragging.*=.*true"
    - from: "Pastel/Views/Panel/FilteredCardListView.swift"
      to: "Pastel/Services/ClipboardMonitor.swift"
      via: "Sets clipboardMonitor.skipNextChange = true on drag start"
      pattern: "skipNextChange.*=.*true"
---

<objective>
Prevent panel dismissal during drag sessions and suppress clipboard monitor self-capture when items are dropped into receiving applications.

Purpose: Without this, the panel hides when the user drags outside its bounds (globalClickMonitor fires), and the receiving app's pasteboard write creates a duplicate clipboard history entry. Both of these break the drag-and-drop UX.

Output: PanelController gains `isDragging` state that gates the global click dismiss monitor. FilteredCardListView's `.onDrag()` closure gains side effects for setting drag state and pausing the clipboard monitor. A global `.leftMouseUp` event monitor detects drag end to restore normal behavior.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-dragdrop/16-CONTEXT.md
@.planning/phases/16-dragdrop/16-RESEARCH.md
@.planning/phases/16-dragdrop/16-01-SUMMARY.md
@Pastel/Views/Panel/PanelController.swift
@Pastel/Views/Panel/FilteredCardListView.swift
@Pastel/Services/ClipboardMonitor.swift
@Pastel/App/AppState.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add isDragging state to PanelController and guard dismiss logic</name>
  <files>Pastel/Views/Panel/PanelController.swift</files>
  <action>
    **1. Add `isDragging` property to PanelController:**

    Add a public mutable property:
    ```swift
    /// Whether a drag session is in progress from a clipboard card.
    /// When true, the global click monitor will NOT dismiss the panel.
    var isDragging: Bool = false
    ```

    Place it in the "Public API" section alongside `isVisible`, `onPasteItem`, etc.

    **2. Guard the globalClickMonitor in `installEventMonitors()`:**

    In the existing globalClickMonitor closure (line ~200-204), add a guard that skips hide() when isDragging is true:

    ```swift
    globalClickMonitor = NSEvent.addGlobalMonitorForEvents(
        matching: [.leftMouseDown, .rightMouseDown]
    ) { [weak self] _ in
        guard self?.isDragging != true else { return }
        self?.hide()
    }
    ```

    This is the critical change -- without it, the panel will dismiss the moment the user drags outside the panel bounds and any global mouse-down event occurs.

    **3. Add drag end monitor management:**

    Add a private property to store the drag-end event monitor:
    ```swift
    private var dragEndMonitor: Any?
    ```

    Add a public method that FilteredCardListView will call when drag starts:
    ```swift
    /// Called when a card drag session begins.
    /// Installs a global mouse-up monitor to detect when the drag ends.
    func dragSessionStarted() {
        isDragging = true

        // Install mouse-up monitor to detect drag end
        dragEndMonitor = NSEvent.addGlobalMonitorForEvents(matching: .leftMouseUp) { [weak self] _ in
            // Delay restoration to allow receiving app to process the drop
            // and avoid capturing the drop as a new clipboard item
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                self?.isDragging = false
            }
            // Clean up this one-shot monitor
            if let monitor = self?.dragEndMonitor {
                NSEvent.removeMonitor(monitor)
                self?.dragEndMonitor = nil
            }
        }
    }
    ```

    **4. Clean up drag monitor in `removeEventMonitors()`:**

    Add cleanup for dragEndMonitor at the end of `removeEventMonitors()`:
    ```swift
    if let monitor = dragEndMonitor {
        NSEvent.removeMonitor(monitor)
        dragEndMonitor = nil
    }
    isDragging = false
    ```

    This ensures that if the panel is hidden while a drag is in progress, the drag state is properly reset.
  </action>
  <verify>
    Build succeeds: `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild -scheme Pastel -configuration Debug build 2>&1 | tail -5`
  </verify>
  <done>
    PanelController has `isDragging` property, globalClickMonitor is guarded, `dragSessionStarted()` method installs a one-shot `.leftMouseUp` monitor, and cleanup is wired into `removeEventMonitors()`. Project builds without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add drag side effects to FilteredCardListView .onDrag() closures</name>
  <files>Pastel/Views/Panel/FilteredCardListView.swift</files>
  <action>
    Update the `.onDrag()` closures added in Plan 01 (both horizontal and vertical layouts) to include side effects for drag state management and self-capture prevention.

    **1. Access PanelController and ClipboardMonitor from the environment.**

    FilteredCardListView does not currently have access to PanelController or ClipboardMonitor. The cleanest approach is to pass callbacks, similar to how `onPaste` works. Add two new optional closures to the view:

    ```swift
    var onDragStarted: (() -> Void)?
    ```

    Add this as a parameter in the init (with default nil):
    ```swift
    init(
        searchText: String,
        selectedLabelIDs: Set<PersistentIdentifier>,
        selectedIndex: Binding<Int?>,
        isShiftHeld: Bool = false,
        onPaste: @escaping (ClipboardItem) -> Void,
        onPastePlainText: @escaping (ClipboardItem) -> Void,
        onTypeToSearch: ((Character) -> Void)? = nil,
        onDragStarted: (() -> Void)? = nil
    )
    ```

    Store it as a property on the view.

    **2. Update both `.onDrag()` closures** (horizontal and vertical layouts) to call `onDragStarted`:

    ```swift
    .onDrag {
        onDragStarted?()
        return DragItemProviderService.createItemProvider(for: item)
    }
    ```

    This fires the callback when drag begins, which will be wired to PanelController.dragSessionStarted() and ClipboardMonitor.skipNextChange by the parent.

    **3. Wire the callback in the parent view (PanelContentView).**

    Find where FilteredCardListView is instantiated in PanelContentView.swift. Add the `onDragStarted` parameter, wiring it to both PanelController and ClipboardMonitor:

    Locate the file: `Pastel/Views/Panel/PanelContentView.swift`

    In the FilteredCardListView instantiation, add:
    ```swift
    onDragStarted: {
        panelActions.onDragStarted?()
    }
    ```

    **4. Add `onDragStarted` callback to PanelActions:**

    In PanelController.swift, add to the PanelActions class:
    ```swift
    var onDragStarted: (() -> Void)?
    ```

    **5. Wire PanelActions.onDragStarted in AppState or PanelController:**

    In PanelController's `show()` method (or `createPanel()`), where panelActions callbacks are synced, add:
    ```swift
    panelActions.onDragStarted = { [weak self] in
        self?.dragSessionStarted()
    }
    ```

    **6. Wire ClipboardMonitor.skipNextChange in AppState:**

    In AppState.swift, find where panelController callbacks are set up (in `setup()` or `setupPanel()`). The `onDragStarted` on PanelController should ALSO set `clipboardMonitor.skipNextChange = true`.

    The best approach: In AppState's setup where `panelController.onPasteItem` is assigned, also add a callback for drag:

    Find in AppState.swift where PanelController callbacks are wired (likely in `setup()` method). Add:
    ```swift
    panelController.onDragStarted = { [weak self] in
        self?.clipboardMonitor?.skipNextChange = true
    }
    ```

    And add the corresponding callback property to PanelController:
    ```swift
    /// Callback invoked when a drag session starts from a clipboard card.
    /// Set by AppState to wire into ClipboardMonitor.skipNextChange.
    var onDragStarted: (() -> Void)?
    ```

    Then update `dragSessionStarted()` to also call this:
    ```swift
    func dragSessionStarted() {
        isDragging = true
        onDragStarted?()  // Notify AppState to pause monitor

        // Install mouse-up monitor...
        // (rest unchanged)
    }
    ```

    And update PanelActions sync to also wire `onDragStarted`:
    ```swift
    panelActions.onDragStarted = { [weak self] in
        self?.dragSessionStarted()
    }
    ```

    **Summary of the callback chain:**
    1. User starts drag -> `.onDrag()` closure fires
    2. Closure calls `onDragStarted?()` (FilteredCardListView callback)
    3. This calls `panelActions.onDragStarted?()` (PanelContentView wiring)
    4. PanelActions calls `panelController.dragSessionStarted()` (PanelController)
    5. `dragSessionStarted()` sets `isDragging = true`, calls `onDragStarted?()` callback
    6. AppState's callback sets `clipboardMonitor?.skipNextChange = true`
    7. Global `.leftMouseUp` monitor fires when drag ends
    8. After 500ms delay, `isDragging` resets to false

    **Important files to modify:** FilteredCardListView.swift, PanelContentView.swift, PanelController.swift, AppState.swift
  </action>
  <verify>
    1. Build succeeds: `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild -scheme Pastel -configuration Debug build 2>&1 | tail -5`
    2. Verify the callback chain: `grep -n "onDragStarted" Pastel/Views/Panel/FilteredCardListView.swift Pastel/Views/Panel/PanelContentView.swift Pastel/Views/Panel/PanelController.swift Pastel/App/AppState.swift`
    3. Verify isDragging guard: `grep -n "isDragging" Pastel/Views/Panel/PanelController.swift`
    4. Verify skipNextChange wiring: `grep -n "skipNextChange" Pastel/App/AppState.swift`
  </verify>
  <done>
    The full drag lifecycle is wired: drag start sets isDragging and skipNextChange, panel stays visible during drag, clipboard monitor skips the next change after drop, and isDragging resets 500ms after mouse-up. All 4 files compile. The callback chain from FilteredCardListView -> PanelActions -> PanelController -> AppState -> ClipboardMonitor is complete.
  </done>
</task>

</tasks>

<verification>
1. Project builds without errors
2. `isDragging` property exists on PanelController
3. globalClickMonitor is guarded with `isDragging` check
4. `dragSessionStarted()` installs global `.leftMouseUp` monitor
5. `.onDrag()` closures in FilteredCardListView call `onDragStarted?()`
6. PanelActions has `onDragStarted` callback
7. AppState wires `clipboardMonitor?.skipNextChange = true` on drag start
8. dragEndMonitor is cleaned up in `removeEventMonitors()`
9. After drag ends (mouse-up + 500ms), `isDragging` resets to false
</verification>

<success_criteria>
- Panel remains visible when user drags a card outside panel bounds
- No duplicate clipboard history entry when item is dropped into another app
- Panel dismisses normally on click-outside after drag session ends
- Clipboard monitor resumes normal operation after drag completes
- No orphaned event monitors (dragEndMonitor cleaned up properly)
</success_criteria>

<output>
After completion, create `.planning/phases/16-dragdrop/16-02-SUMMARY.md`
</output>
