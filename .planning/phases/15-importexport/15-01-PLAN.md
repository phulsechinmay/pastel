---
phase: 15-importexport
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Pastel/Services/ImportExportService.swift
  - Pastel/Resources/Info.plist
autonomous: true

must_haves:
  truths:
    - "Clipboard history can be serialized to JSON with all metadata preserved"
    - "Image-type and concealed items are excluded from export"
    - "Imported items with duplicate contentHash are skipped, not upserted"
    - "Import creates missing labels from the file while preserving existing labels"
    - "Import reports counts: imported, skipped, labels created"
  artifacts:
    - path: "Pastel/Services/ImportExportService.swift"
      provides: "Export/import logic with Codable transfer structs, deduplication, batch insert"
      exports: ["ImportExportService", "PastelExport", "ExportedItem", "ExportedLabel", "ImportResult"]
    - path: "Pastel/Resources/Info.plist"
      provides: "UTExportedTypeDeclarations for .pastel file type"
      contains: "app.pastel.export"
  key_links:
    - from: "Pastel/Services/ImportExportService.swift"
      to: "Pastel/Models/ClipboardItem.swift"
      via: "SwiftData FetchDescriptor queries and model inserts"
      pattern: "FetchDescriptor<ClipboardItem>"
    - from: "Pastel/Services/ImportExportService.swift"
      to: "Pastel/Models/Label.swift"
      via: "Label fetch, create, and relationship wiring"
      pattern: "FetchDescriptor<Label>"
---

<objective>
Create the ImportExportService with Codable transfer structs, export/import logic, and register the .pastel UTType.

Purpose: This is the core data layer for Phase 15 -- all serialization, deduplication, label resolution, and batch import logic lives here. The UI (Plan 02) will call these methods.

Output: ImportExportService.swift with working export and import functions, Info.plist with UTType registration.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-importexport/15-RESEARCH.md

@Pastel/Models/ClipboardItem.swift
@Pastel/Models/Label.swift
@Pastel/Models/ContentType.swift
@Pastel/Models/LabelColor.swift
@Pastel/Resources/Info.plist
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ImportExportService with Codable transfer structs and export/import logic</name>
  <files>Pastel/Services/ImportExportService.swift</files>
  <action>
Create `Pastel/Services/ImportExportService.swift` with the following components:

**1. UTType extension:**
```swift
import UniformTypeIdentifiers
extension UTType {
    static let pastelExport = UTType(exportedAs: "app.pastel.export")
}
```

**2. Codable transfer structs:**

`PastelExport` -- top-level container:
- `version: Int` (always 1)
- `exportDate: Date`
- `items: [ExportedItem]`
- `labels: [ExportedLabel]`

`ExportedItem` -- mirrors ClipboardItem without SwiftData persistence:
- `textContent: String?`
- `htmlContent: String?`
- `rtfData: Data?` (JSONEncoder handles base64 automatically)
- `contentType: String` (raw value of ContentType enum)
- `timestamp: Date`
- `sourceAppBundleID: String?`
- `sourceAppName: String?`
- `characterCount: Int`
- `byteCount: Int`
- `isConcealed: Bool`
- `contentHash: String`
- `title: String?`
- `detectedLanguage: String?`
- `detectedColorHex: String?`
- `labelNames: [String]` (label names for portability, NOT PersistentIdentifiers)

`ExportedLabel`:
- `name: String`
- `colorName: String`
- `sortOrder: Int`
- `emoji: String?`

`ImportResult`:
- `importedCount: Int`
- `skippedCount: Int`
- `labelsCreated: Int`

**3. ImportExportService class** (`@MainActor @Observable`):

Properties:
- `isProcessing: Bool` (for UI binding)
- `progress: Double` (0.0 to 1.0, for determinate ProgressView)
- `progressMessage: String` (e.g., "Exporting 150 items...", "Imported 200, skipped 50")

`exportHistory(modelContext:) throws -> Data`:
- Fetch all ClipboardItem where `isConcealed == false` AND `contentType != "image"` using FetchDescriptor with #Predicate, sorted by timestamp descending
- Fetch all Label sorted by sortOrder
- Map to ExportedItem array (use `item.labels.map(\.name)` for labelNames)
- Map to ExportedLabel array
- Create PastelExport with version: 1, exportDate: .now
- Encode with JSONEncoder using `.iso8601` dateEncodingStrategy, `.base64` dataEncodingStrategy, `.prettyPrinted` and `.sortedKeys` outputFormatting
- Update progress/progressMessage before and after
- Return encoded Data

`importHistory(from data: Data, modelContext: ModelContext) throws -> ImportResult`:
- Decode PastelExport using JSONDecoder with `.iso8601` dateDecodingStrategy, `.base64` dataDecodingStrategy
- Check `export.version == 1`, throw descriptive error if not
- **Phase 1 -- Label resolution:**
  - Fetch all existing Label into a `[String: Label]` map keyed by name
  - For each ExportedLabel where name does NOT exist in map: create new Label with the exported colorName, emoji, and sortOrder offset (maxExistingSortOrder + 1 + index). Insert and add to map. Track labelsCreated count.
  - Save after all labels created.
- **Phase 2 -- Item import with deduplication:**
  - For each ExportedItem: check if contentHash already exists via FetchDescriptor + fetchCount. If exists, increment skippedCount and continue.
  - If not duplicate: create ClipboardItem from ExportedItem fields. Set title, detectedLanguage, detectedColorHex after init. Wire label relationships by looking up each labelName in the label map and appending to item.labels.
  - Insert item. Increment importedCount.
  - **Batch save every 50 items** to control memory (call `modelContext.save()` and update progress).
  - After loop, final `modelContext.save()` and set progress to 1.0.
- Return ImportResult with counts.

**CRITICAL -- avoid these pitfalls:**
- Do NOT rely on SwiftData's @Attribute(.unique) upsert for deduplication -- it silently overwrites existing items. Always pre-check with fetchCount.
- Do NOT make @Model classes Codable. Use separate transfer structs.
- Do NOT include imagePath/thumbnailPath/urlFaviconPath/urlPreviewImagePath in ExportedItem -- these are disk file references that are machine-specific and meaningless on import.
- Do NOT include the deprecated `label: Label?` single-label field in export. Only export the `labels: [Label]` array (as labelNames).
- For the #Predicate filtering contentType != "image": use `item.contentType != "image"` (it's stored as String).
  </action>
  <verify>
Build the project with `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild -project Pastel.xcodeproj -scheme Pastel -configuration Debug build 2>&1 | tail -5`. Must compile with zero errors.
  </verify>
  <done>
ImportExportService.swift exists with PastelExport/ExportedItem/ExportedLabel Codable structs, UTType.pastelExport extension, exportHistory and importHistory methods, ImportResult return type, batch save logic, and pre-check deduplication. Project compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register .pastel UTType in Info.plist</name>
  <files>Pastel/Resources/Info.plist</files>
  <action>
Add UTExportedTypeDeclarations to `Pastel/Resources/Info.plist` inside the root `<dict>`, after the existing NSAccessibilityUsageDescription entry.

Add this XML block:
```xml
<key>UTExportedTypeDeclarations</key>
<array>
    <dict>
        <key>UTTypeIdentifier</key>
        <string>app.pastel.export</string>
        <key>UTTypeDescription</key>
        <string>Pastel Clipboard History</string>
        <key>UTTypeConformsTo</key>
        <array>
            <string>public.json</string>
        </array>
        <key>UTTypeTagSpecification</key>
        <dict>
            <key>public.filename-extension</key>
            <array>
                <string>pastel</string>
            </array>
        </dict>
    </dict>
</array>
```

This registers `app.pastel.export` as a custom UTType conforming to `public.json` with the `.pastel` file extension. It matches the `UTType.pastelExport = UTType(exportedAs: "app.pastel.export")` in ImportExportService.swift.

Do NOT add CFBundleDocumentTypes (file association / double-click-to-open is not needed for Phase 15).
  </action>
  <verify>
Read Info.plist and confirm UTExportedTypeDeclarations is present with `app.pastel.export` identifier. Build project to confirm plist is valid XML.
  </verify>
  <done>
Info.plist contains UTExportedTypeDeclarations with app.pastel.export identifier, public.json conformance, and .pastel file extension. Project builds.
  </done>
</task>

</tasks>

<verification>
1. Project compiles: `xcodebuild -project Pastel.xcodeproj -scheme Pastel build` succeeds
2. ImportExportService.swift contains: PastelExport, ExportedItem, ExportedLabel structs (all Codable)
3. ImportExportService.swift contains: exportHistory method that filters out image and concealed items
4. ImportExportService.swift contains: importHistory method with pre-check deduplication (fetchCount before insert)
5. ImportExportService.swift contains: batch save every 50 items in import loop
6. ImportExportService.swift contains: label resolution (create missing labels, wire relationships)
7. Info.plist contains UTExportedTypeDeclarations with app.pastel.export
</verification>

<success_criteria>
- PastelExport, ExportedItem, ExportedLabel are Codable structs decoupled from SwiftData
- Export fetches non-concealed, non-image items and serializes to JSON with ISO 8601 dates and base64 Data
- Import decodes, resolves labels by name (creating missing ones), pre-checks contentHash for deduplication, inserts items with batch saves every 50
- ImportResult reports importedCount, skippedCount, labelsCreated
- UTType.pastelExport registered in code and Info.plist
- Project compiles
</success_criteria>

<output>
After completion, create `.planning/phases/15-importexport/15-01-SUMMARY.md`
</output>
