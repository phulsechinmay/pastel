---
phase: 16-dragdrop
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Pastel/Services/DragItemProviderService.swift
  - Pastel/Views/Panel/FilteredCardListView.swift
autonomous: true

must_haves:
  truths:
    - "User can drag a text card from the panel and drop it into TextEdit, and the text appears"
    - "User can drag a code card and drop it into a text editor as plain text"
    - "User can drag a URL card and drop it into Safari's address bar, and the URL is accepted"
    - "User can drag an image card and drop it into Finder or Preview, and the image file is received"
    - "User can drag a rich text card and drop it into a rich text editor with formatting preserved"
    - "User can drag a file card and drop it into Finder"
    - "Existing single-click selection and double-click paste still work after adding drag"
    - "Existing label drag-and-drop assignment still works (no type collision)"
  artifacts:
    - path: "Pastel/Services/DragItemProviderService.swift"
      provides: "NSItemProvider construction for all 7 ContentType cases"
      contains: "createItemProvider"
    - path: "Pastel/Views/Panel/FilteredCardListView.swift"
      provides: ".onDrag() modifier on all clipboard cards in both layouts"
      contains: ".onDrag"
  key_links:
    - from: "Pastel/Views/Panel/FilteredCardListView.swift"
      to: "Pastel/Services/DragItemProviderService.swift"
      via: ".onDrag closure calls DragItemProviderService.createItemProvider(for:)"
      pattern: "DragItemProviderService\\.createItemProvider"
    - from: "Pastel/Services/DragItemProviderService.swift"
      to: "Pastel/Services/ImageStorageService.swift"
      via: "Resolves image file URL for .image items"
      pattern: "ImageStorageService\\.shared\\.resolveImageURL"
---

<objective>
Add drag-and-drop initiation from clipboard cards using SwiftUI's `.onDrag()` modifier with proper NSItemProvider construction for all 7 content types.

Purpose: This is the core drag functionality -- users can grab any clipboard card and drag it into another macOS application. The `.onDrag()` modifier (not `.draggable()`) is used to avoid type collision with the existing `.dropDestination(for: String.self)` used for label assignment on the same cards.

Output: DragItemProviderService with NSItemProvider construction for all content types, `.onDrag()` wired to both vertical and horizontal card layouts in FilteredCardListView.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-dragdrop/16-CONTEXT.md
@.planning/phases/16-dragdrop/16-RESEARCH.md
@Pastel/Views/Panel/FilteredCardListView.swift
@Pastel/Views/Panel/ClipboardCardView.swift
@Pastel/Services/ImageStorageService.swift
@Pastel/Services/PasteService.swift
@Pastel/Models/ContentType.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DragItemProviderService</name>
  <files>Pastel/Services/DragItemProviderService.swift</files>
  <action>
    Create a new service `DragItemProviderService` with a single static method:

    ```swift
    static func createItemProvider(for item: ClipboardItem) -> NSItemProvider
    ```

    This method constructs an NSItemProvider with the correct UTTypes based on `item.type`:

    **Case `.text`, `.code`, `.color`:**
    - `NSItemProvider(object: (item.textContent ?? "") as NSString)`
    - NSString conforms to NSItemProviderWriting, auto-registers `.plainText`

    **Case `.richText`:**
    - Create empty `NSItemProvider()`
    - If `item.rtfData` exists: register via `provider.registerDataRepresentation(forTypeIdentifier: UTType.rtf.identifier, visibility: .all)` returning the RTF data
    - Always register plain text fallback: `provider.registerObject((item.textContent ?? "") as NSString, visibility: .all)`
    - Register RTF FIRST so richer representation takes priority

    **Case `.url`:**
    - If `item.textContent` is a valid URL: `NSItemProvider(object: url as NSURL)`
    - NSURL auto-registers both `.url` and `.plainText` representations
    - Fallback: if URL parsing fails, use NSString as plain text

    **Case `.image`:**
    - If `item.imagePath` exists: resolve via `ImageStorageService.shared.resolveImageURL(imagePath)`
    - Check `FileManager.default.fileExists(atPath: fileURL.path)` before creating provider
    - If file exists: `NSItemProvider(contentsOf: fileURL)` -- this reads UTType from file extension
    - If file missing: return empty `NSItemProvider()` (graceful degradation, no crash)

    **Case `.file`:**
    - If `item.textContent` has a file path: `NSItemProvider(contentsOf: URL(fileURLWithPath: filePath))`
    - If nil or provider creation fails: return empty `NSItemProvider()`

    Import `UniformTypeIdentifiers` for UTType, `Foundation` for NSItemProvider, and reference `ImageStorageService`.

    **Important:** Do NOT import SwiftUI or SwiftData in this service. Keep it a pure Foundation/AppKit utility.
  </action>
  <verify>
    Build succeeds: `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild -scheme Pastel -configuration Debug build 2>&1 | tail -5`
  </verify>
  <done>
    DragItemProviderService.swift exists with createItemProvider(for:) handling all 7 ContentType cases. Project builds without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire .onDrag() to clipboard cards in FilteredCardListView</name>
  <files>Pastel/Views/Panel/FilteredCardListView.swift</files>
  <action>
    Add `.onDrag()` modifier to clipboard cards in BOTH the horizontal layout (line ~111, the ClipboardCardView inside LazyHStack) and the vertical layout (line ~169, the ClipboardCardView inside LazyVStack).

    **Modifier placement:** Add `.onDrag` BEFORE the `.onTapGesture(count: 2)` modifier on each ClipboardCardView. This is critical -- `.onDrag()` must be earlier in the modifier chain so SwiftUI can correctly arbitrate between drag and tap gestures. The modifier chain on each card should be:

    ```swift
    ClipboardCardView(item: item, ...)
        .frame(width: 260, height: 195)  // only in horizontal layout
        .clipped()                        // only in horizontal layout
        .onDrag {
            DragItemProviderService.createItemProvider(for: item)
        }
        .onTapGesture(count: 2) { ... }
        .onTapGesture(count: 1) { ... }
        .dropDestination(for: String.self) { ... }
        .id(index)
    ```

    For the **vertical layout** (no .frame/.clipped), the same ordering applies:

    ```swift
    ClipboardCardView(item: item, ...)
        .onDrag {
            DragItemProviderService.createItemProvider(for: item)
        }
        .onTapGesture(count: 2) { ... }
        .onTapGesture(count: 1) { ... }
        .dropDestination(for: String.self) { ... }
        .id(index)
    ```

    **Why `.onDrag()` and NOT `.draggable()`:** The cards already have `.dropDestination(for: String.self)` for label assignment via PersistentIdentifier strings. Using `.draggable(String)` would create a type collision where dragging a card could trigger label assignment on another card. `.onDrag()` returns NSItemProvider with specific UTTypes (`.plainText`, `.fileURL`, `.url`, `.rtf`) that do NOT match the String-based `.dropDestination`, avoiding this conflict.

    **Do NOT add drag preview** in this plan -- the default SwiftUI snapshot preview is sufficient. Custom previews will be added if needed in a future iteration.

    Add `import UniformTypeIdentifiers` at the top of the file if not already present (it may be needed for UTType references, though DragItemProviderService handles the actual UTType usage).
  </action>
  <verify>
    1. Build succeeds: `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild -scheme Pastel -configuration Debug build 2>&1 | tail -5`
    2. Verify .onDrag is present in both layouts: `grep -n "\.onDrag" Pastel/Views/Panel/FilteredCardListView.swift` shows 2 occurrences
  </verify>
  <done>
    `.onDrag()` modifier is present on clipboard cards in both horizontal and vertical layouts of FilteredCardListView. Cards can be dragged to initiate inter-app drag-and-drop. The `.dropDestination` for label assignment remains intact and does not conflict. Project builds without errors.
  </done>
</task>

</tasks>

<verification>
1. Project builds without errors
2. `.onDrag()` appears exactly twice in FilteredCardListView.swift (one per layout)
3. DragItemProviderService.createItemProvider handles all 7 ContentType cases
4. No `.draggable()` modifier added to cards (only `.onDrag()`)
5. Existing `.dropDestination(for: String.self)` for label assignment is unchanged
6. Existing `.onTapGesture` modifiers for click/double-click are unchanged
</verification>

<success_criteria>
- DragItemProviderService.swift exists with complete NSItemProvider construction for text, richText, code, color, url, image, and file types
- FilteredCardListView.swift has .onDrag() on cards in both horizontal and vertical layouts
- Project compiles successfully
- No type collision between card drag (.onDrag with NSItemProvider) and label drop (.dropDestination for String)
</success_criteria>

<output>
After completion, create `.planning/phases/16-dragdrop/16-01-SUMMARY.md`
</output>
