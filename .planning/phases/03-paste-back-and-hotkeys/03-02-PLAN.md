---
phase: 03-paste-back-and-hotkeys
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - Pastel/Views/Panel/PanelContentView.swift
  - Pastel/Views/Panel/ClipboardCardView.swift
  - Pastel/Views/Onboarding/AccessibilityPromptView.swift
  - Pastel/PastelApp.swift
autonomous: true

must_haves:
  truths:
    - "User can navigate clipboard cards with up/down arrow keys"
    - "Selected card has a visible highlight distinct from hover state"
    - "User can press Enter to paste the currently selected card"
    - "User can double-click any card to paste its content"
    - "Panel auto-dismisses after a paste action is triggered"
    - "Selection resets to nil each time the panel is shown"
    - "ScrollView scrolls to keep the selected card visible"
    - "On first launch without Accessibility permission, user sees an onboarding prompt"
    - "Onboarding prompt explains why Accessibility permission is needed"
    - "Onboarding prompt has a button to trigger the macOS system permission dialog"
    - "Onboarding prompt has a button to open System Settings directly"
  artifacts:
    - path: "Pastel/Views/Panel/PanelContentView.swift"
      provides: "Selection state, keyboard navigation, paste dispatch"
      contains: "selectedIndex"
    - path: "Pastel/Views/Panel/ClipboardCardView.swift"
      provides: "Selection highlight and double-click handler"
      contains: "isSelected"
    - path: "Pastel/Views/Onboarding/AccessibilityPromptView.swift"
      provides: "Accessibility permission onboarding UI"
      contains: "AccessibilityService"
    - path: "Pastel/PastelApp.swift"
      provides: "Onboarding flow integration at app launch"
      contains: "AccessibilityPromptView\\|accessibilityChecked"
  key_links:
    - from: "Pastel/Views/Panel/PanelContentView.swift"
      to: "Pastel/Views/Panel/PanelController.swift"
      via: "PanelActions environment object triggers paste callback"
      pattern: "panelActions.*pasteItem"
    - from: "Pastel/Views/Panel/PanelContentView.swift"
      to: "Pastel/Views/Panel/ClipboardCardView.swift"
      via: "Passes isSelected and onPaste to each card"
      pattern: "isSelected.*selectedIndex.*==.*index"
    - from: "Pastel/Views/Panel/ClipboardCardView.swift"
      to: "Pastel/Views/Panel/PanelContentView.swift"
      via: "Double-click calls onPaste closure from parent"
      pattern: "onTapGesture.*count.*2"
    - from: "Pastel/Views/Onboarding/AccessibilityPromptView.swift"
      to: "Pastel/Services/AccessibilityService.swift"
      via: "Calls requestPermission and openAccessibilitySettings"
      pattern: "AccessibilityService\\.requestPermission|AccessibilityService\\.openAccessibilitySettings"
---

<objective>
Add keyboard navigation (arrow keys + Enter), double-click paste, selection highlighting on cards, and an Accessibility permission onboarding view. After this plan, users can browse cards with keyboard, paste via double-click or Enter, and are guided through Accessibility permission on first launch.

Purpose: This completes all Phase 3 requirements. Plan 01 built the paste infrastructure; this plan wires the UI triggers and onboarding that make paste-back actually usable.

Output: Modified PanelContentView (selection + keyboard nav), modified ClipboardCardView (selection highlight + double-click), new AccessibilityPromptView, modified PastelApp (onboarding flow). All Phase 3 success criteria met.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-paste-back-and-hotkeys/03-RESEARCH.md
@.planning/phases/03-paste-back-and-hotkeys/03-01-SUMMARY.md

@Pastel/Views/Panel/PanelContentView.swift
@Pastel/Views/Panel/ClipboardCardView.swift
@Pastel/Views/Panel/PanelController.swift
@Pastel/Views/Panel/SlidingPanel.swift
@Pastel/App/AppState.swift
@Pastel/Services/AccessibilityService.swift
@Pastel/Services/PasteService.swift
@Pastel/PastelApp.swift
@Pastel/Models/ClipboardItem.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Keyboard navigation, selection highlight, and double-click paste</name>
  <files>
    Pastel/Views/Panel/PanelContentView.swift
    Pastel/Views/Panel/ClipboardCardView.swift
  </files>
  <action>
    **1. Update PanelContentView.swift for selection state and keyboard navigation.**

    Add to PanelContentView:
    - `@Environment(PanelActions.self) private var panelActions` -- to access the paste callback from Plan 01.
    - `@State private var selectedIndex: Int? = nil` -- tracks which card is selected.

    Replace the ScrollView section with a `ScrollViewReader`-wrapped version:

    ```swift
    ScrollViewReader { proxy in
        ScrollView {
            LazyVStack(spacing: 6) {
                ForEach(Array(items.enumerated()), id: \.element.id) { index, item in
                    ClipboardCardView(
                        item: item,
                        isSelected: selectedIndex == index,
                        onPaste: { pasteItem(item) }
                    )
                    .id(index)
                    .onTapGesture(count: 2) {
                        pasteItem(item)
                    }
                    .onTapGesture(count: 1) {
                        selectedIndex = index
                    }
                }
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 6)
        }
        .onChange(of: selectedIndex) { _, newValue in
            if let newValue {
                withAnimation(.easeInOut(duration: 0.15)) {
                    proxy.scrollTo(newValue, anchor: .center)
                }
            }
        }
    }
    ```

    **IMPORTANT:** The double-tap gesture (count: 2) MUST be placed BEFORE the single-tap gesture (count: 1) on the same view. SwiftUI processes higher-count tap gestures first when declared first.

    Add keyboard handling with `.onKeyPress` modifiers on the outermost VStack (after `.frame(maxWidth:maxHeight:)`):

    ```swift
    .focusable()
    .focusEffectDisabled()
    .onKeyPress(.upArrow) {
        moveSelection(by: -1)
        return .handled
    }
    .onKeyPress(.downArrow) {
        moveSelection(by: 1)
        return .handled
    }
    .onKeyPress(.return) {
        if let index = selectedIndex, index < items.count {
            pasteItem(items[index])
        }
        return .handled
    }
    ```

    Add private helper methods:

    ```swift
    private func moveSelection(by offset: Int) {
        guard !items.isEmpty else { return }
        if let current = selectedIndex {
            selectedIndex = max(0, min(items.count - 1, current + offset))
        } else {
            selectedIndex = 0
        }
    }

    private func pasteItem(_ item: ClipboardItem) {
        panelActions.pasteItem?(item)
    }
    ```

    **Reset selection when panel appears:** Add an `.onAppear` modifier to the outermost VStack:
    ```swift
    .onAppear {
        selectedIndex = nil
    }
    ```

    **Fallback note:** If `.onKeyPress` does not work inside the NSPanel (key events not received despite `.focusable()`), the executor should fall back to extending the existing `localKeyMonitor` in PanelController.swift. The fallback approach:
    - In PanelController, extend the existing `localKeyMonitor` to handle keyCode 126 (up arrow), 125 (down arrow), and 36 (return/enter) in addition to 53 (escape).
    - Add callback closures on PanelController: `var onArrowUp: (() -> Void)?`, `var onArrowDown: (() -> Void)?`, `var onReturn: (() -> Void)?`.
    - Wire these through PanelActions to the SwiftUI view.
    - Only use this fallback if `.onKeyPress` demonstrably fails during testing.

    **2. Update ClipboardCardView.swift to accept isSelected and show selection highlight.**

    Add parameters to ClipboardCardView:
    - `var isSelected: Bool = false`
    - `var onPaste: (() -> Void)? = nil`

    **Do NOT add .onTapGesture to ClipboardCardView itself.** The tap gestures are on the ForEach item wrapper in PanelContentView (to have access to the index). ClipboardCardView only handles visual display.

    Update the `.background()` modifier to incorporate selection state:

    ```swift
    .background(
        isSelected ? Color.accentColor.opacity(0.3)
            : isHovered ? Color.white.opacity(0.12)
            : Color.white.opacity(0.06),
        in: RoundedRectangle(cornerRadius: 8)
    )
    ```

    Add a subtle border for selected state to make it visually distinct:

    ```swift
    .overlay(
        RoundedRectangle(cornerRadius: 8)
            .strokeBorder(isSelected ? Color.accentColor.opacity(0.5) : Color.clear, lineWidth: 1.5)
    )
    ```

    Add `.animation(.easeInOut(duration: 0.15), value: isSelected)` alongside the existing hover animation.

    Update the existing `ClipboardCardView(item:)` initializer to include the new parameters with defaults so existing call sites (if any outside PanelContentView) don't break:
    ```swift
    init(item: ClipboardItem, isSelected: Bool = false, onPaste: (() -> Void)? = nil) {
        self.item = item
        self.isSelected = isSelected
        self.onPaste = onPaste
    }
    ```

    **Visual design for selection:**
    - Selected: `Color.accentColor.opacity(0.3)` background + `Color.accentColor.opacity(0.5)` border (1.5pt)
    - Hovered (not selected): `Color.white.opacity(0.12)` background (existing)
    - Default: `Color.white.opacity(0.06)` background (existing)
    - Selected + Hovered: Selection style wins (selected takes priority in the ternary)
  </action>
  <verify>
    1. Run `xcodegen generate && xcodebuild -project Pastel.xcodeproj -scheme Pastel -configuration Debug build 2>&1 | tail -20` to confirm clean build.
    2. Verify selection state: `grep "selectedIndex" Pastel/Views/Panel/PanelContentView.swift` should show @State declaration and usage.
    3. Verify keyboard handling: `grep "onKeyPress" Pastel/Views/Panel/PanelContentView.swift` should show 3 handlers (up, down, return).
    4. Verify scroll tracking: `grep "ScrollViewReader" Pastel/Views/Panel/PanelContentView.swift`.
    5. Verify paste dispatch: `grep "pasteItem" Pastel/Views/Panel/PanelContentView.swift` should show the helper method.
    6. Verify PanelActions environment: `grep "PanelActions" Pastel/Views/Panel/PanelContentView.swift`.
    7. Verify double-click: `grep "onTapGesture.*count.*2" Pastel/Views/Panel/PanelContentView.swift`.
    8. Verify selection highlight: `grep "isSelected" Pastel/Views/Panel/ClipboardCardView.swift` should show the property and background usage.
    9. Verify selection border: `grep "strokeBorder" Pastel/Views/Panel/ClipboardCardView.swift`.
    10. Verify onAppear reset: `grep "onAppear" Pastel/Views/Panel/PanelContentView.swift`.
  </verify>
  <done>
    - PanelContentView has @State selectedIndex tracking current selection
    - PanelContentView has .onKeyPress handlers for up arrow, down arrow, and return
    - PanelContentView has .focusable() and .focusEffectDisabled() for keyboard focus
    - PanelContentView wraps ScrollView in ScrollViewReader for auto-scrolling to selection
    - PanelContentView has double-click gesture (count: 2) on each card
    - PanelContentView has single-click gesture (count: 1) to select card
    - PanelContentView calls panelActions.pasteItem when paste is triggered
    - PanelContentView resets selectedIndex to nil on .onAppear
    - ClipboardCardView has isSelected parameter with default false
    - ClipboardCardView shows accentColor background + border when selected
    - ClipboardCardView selection highlight is visually distinct from hover highlight
    - Project compiles with zero errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Accessibility permission onboarding view</name>
  <files>
    Pastel/Views/Onboarding/AccessibilityPromptView.swift
    Pastel/PastelApp.swift
  </files>
  <action>
    **1. Create `Pastel/Views/Onboarding/AccessibilityPromptView.swift`.**

    Create the `Pastel/Views/Onboarding/` directory if it does not exist.

    A SwiftUI view that explains why Accessibility permission is needed and provides buttons to grant it. This view is shown as a sheet or overlay at app launch when permission is not granted.

    ```swift
    import SwiftUI

    struct AccessibilityPromptView: View {
        @State private var isChecking = false
        @State private var isGranted = false
        @Environment(\.dismiss) private var dismiss

        /// Timer-based polling to detect when user grants permission in System Settings
        let pollTimer = Timer.publish(every: 1.0, on: .main, in: .common).autoconnect()

        var body: some View {
            VStack(spacing: 20) {
                // Icon
                Image(systemName: "accessibility")
                    .font(.system(size: 48))
                    .foregroundStyle(.secondary)

                // Title
                Text("Accessibility Permission Required")
                    .font(.title2)
                    .fontWeight(.semibold)

                // Explanation
                Text("Pastel needs Accessibility permission to paste clipboard items into other apps. Without it, you can browse your clipboard history but cannot paste directly.")
                    .font(.body)
                    .foregroundStyle(.secondary)
                    .multilineTextAlignment(.center)
                    .fixedSize(horizontal: false, vertical: true)

                // Buttons
                VStack(spacing: 12) {
                    Button {
                        AccessibilityService.requestPermission()
                        isChecking = true
                    } label: {
                        Text("Grant Permission")
                            .frame(maxWidth: .infinity)
                    }
                    .buttonStyle(.borderedProminent)
                    .controlSize(.large)

                    Button {
                        AccessibilityService.openAccessibilitySettings()
                        isChecking = true
                    } label: {
                        Text("Open System Settings")
                            .frame(maxWidth: .infinity)
                    }
                    .buttonStyle(.bordered)
                    .controlSize(.large)

                    Button("Skip for Now") {
                        dismiss()
                    }
                    .buttonStyle(.plain)
                    .foregroundStyle(.secondary)
                    .font(.caption)
                }
            }
            .padding(32)
            .frame(width: 360)
            .onReceive(pollTimer) { _ in
                guard isChecking else { return }
                if AccessibilityService.isGranted {
                    isGranted = true
                    dismiss()
                }
            }
            .preferredColorScheme(.dark)
        }
    }
    ```

    Key design decisions:
    - "Grant Permission" button calls `AccessibilityService.requestPermission()` which shows the macOS system dialog.
    - "Open System Settings" opens directly to Privacy > Accessibility pane.
    - "Skip for Now" dismisses without granting -- paste-back will prompt again on first use.
    - Polls `AXIsProcessTrusted()` every 1 second while `isChecking` is true to auto-dismiss when permission is granted.
    - Always-dark theme via `.preferredColorScheme(.dark)`.

    **2. Integrate onboarding into PastelApp.swift.**

    Add `@State private var showAccessibilityPrompt = false` to PastelApp.

    In PastelApp.init(), AFTER the existing `state.setupPanel(modelContainer: container)` line, check if accessibility is not granted:
    ```swift
    // Don't set showAccessibilityPrompt in init -- it's a @State.
    // We'll check in onAppear instead.
    ```

    Actually, since PastelApp is a MenuBarExtra app with no main window, the onboarding view should be shown as a standalone NSWindow (not a sheet on the MenuBarExtra). Add a method to AppState or handle in PastelApp:

    The simplest approach: Add the Accessibility check to AppState and show the prompt window via PanelController's infrastructure or a dedicated window.

    **Better approach for menu-bar-only app:** Use AppState to track whether the prompt should be shown, and use an NSWindow to present it:

    In `AppState.swift`, add:
    ```swift
    var showAccessibilityPrompt = false

    func checkAccessibilityOnLaunch() {
        if !AccessibilityService.isGranted {
            showAccessibilityPrompt = true
        }
    }
    ```

    In `PastelApp.swift`, after `state.setupPanel(modelContainer: container)` in init, add:
    ```swift
    state.checkAccessibilityOnLaunch()
    ```

    Then in the PastelApp body, add a Window scene for the onboarding:
    ```swift
    Window("Accessibility", id: "accessibility-prompt") {
        AccessibilityPromptView()
            .environment(appState)
    }
    .windowStyle(.hiddenTitleBar)
    .windowResizability(.contentSize)
    .defaultPosition(.center)
    ```

    Wait -- SwiftUI Window scenes for menu bar apps can be tricky. A simpler and more reliable approach:

    **Use an NSWindow directly from AppState.** Add to AppState:

    ```swift
    private var accessibilityWindow: NSWindow?

    func checkAccessibilityOnLaunch() {
        guard !AccessibilityService.isGranted else { return }

        let promptView = AccessibilityPromptView(onDismiss: { [weak self] in
            self?.accessibilityWindow?.close()
            self?.accessibilityWindow = nil
        })
        .preferredColorScheme(.dark)

        let hostingView = NSHostingView(rootView: promptView)
        hostingView.translatesAutoresizingMaskIntoConstraints = false

        let window = NSWindow(
            contentRect: NSRect(x: 0, y: 0, width: 360, height: 400),
            styleMask: [.titled, .closable],
            backing: .buffered,
            defer: true
        )
        window.contentView = hostingView
        window.title = "Pastel"
        window.center()
        window.isReleasedWhenClosed = false
        window.appearance = NSAppearance(named: .darkAqua)
        window.makeKeyAndOrderFront(nil)
        // Bring app to front for the onboarding window
        NSApp.activate(ignoringOtherApps: true)
        self.accessibilityWindow = window
    }
    ```

    Update AccessibilityPromptView to accept an `onDismiss` closure instead of using SwiftUI `@Environment(\.dismiss)` (since it's not in a sheet):

    ```swift
    struct AccessibilityPromptView: View {
        var onDismiss: () -> Void = {}
        @State private var isChecking = false

        let pollTimer = Timer.publish(every: 1.0, on: .main, in: .common).autoconnect()

        // ... body same as above but replace dismiss() calls with onDismiss()
    }
    ```

    The "Skip for Now" and auto-dismiss-on-granted both call `onDismiss()`.

    In PastelApp.swift init(), after `state.setupPanel(modelContainer: container)`:
    ```swift
    state.checkAccessibilityOnLaunch()
    ```

    No changes to PastelApp body -- the window is managed imperatively by AppState.

    **IMPORTANT:** Do NOT show the prompt if permission is already granted. `checkAccessibilityOnLaunch()` guards with `!AccessibilityService.isGranted`.
  </action>
  <verify>
    1. Run `xcodegen generate && xcodebuild -project Pastel.xcodeproj -scheme Pastel -configuration Debug build 2>&1 | tail -20` to confirm clean build.
    2. Verify AccessibilityPromptView exists: `ls Pastel/Views/Onboarding/AccessibilityPromptView.swift`.
    3. Verify prompt uses AccessibilityService: `grep "AccessibilityService" Pastel/Views/Onboarding/AccessibilityPromptView.swift` should show requestPermission and openAccessibilitySettings calls.
    4. Verify polling: `grep "pollTimer\|Timer.publish" Pastel/Views/Onboarding/AccessibilityPromptView.swift`.
    5. Verify AppState integration: `grep "checkAccessibilityOnLaunch\|accessibilityWindow" Pastel/App/AppState.swift`.
    6. Verify PastelApp calls checkAccessibilityOnLaunch: `grep "checkAccessibilityOnLaunch" Pastel/PastelApp.swift`.
    7. Verify onDismiss callback: `grep "onDismiss" Pastel/Views/Onboarding/AccessibilityPromptView.swift`.
  </verify>
  <done>
    - AccessibilityPromptView exists in Pastel/Views/Onboarding/ with clear explanation text
    - AccessibilityPromptView has "Grant Permission" button calling AccessibilityService.requestPermission()
    - AccessibilityPromptView has "Open System Settings" button calling AccessibilityService.openAccessibilitySettings()
    - AccessibilityPromptView has "Skip for Now" dismissal option
    - AccessibilityPromptView polls AXIsProcessTrusted every 1s and auto-dismisses when granted
    - AppState.checkAccessibilityOnLaunch() shows prompt window if permission not granted
    - PastelApp calls checkAccessibilityOnLaunch in init
    - Onboarding window is dark-themed NSWindow, centered, closable
    - Permission prompt only shown if not already granted
    - Project compiles with zero errors
  </done>
</task>

</tasks>

<verification>
1. `xcodegen generate && xcodebuild -project Pastel.xcodeproj -scheme Pastel -configuration Debug build` succeeds with zero errors
2. Arrow keys (up/down) move `selectedIndex` in PanelContentView
3. Selected card shows accentColor background + border (distinct from hover)
4. Enter key on selected card calls `pasteItem()` which routes through PanelActions -> PasteService
5. Double-click on any card calls `pasteItem()` which routes through PanelActions -> PasteService
6. Single-click selects a card (sets selectedIndex)
7. Selection resets to nil when panel appears (.onAppear)
8. ScrollViewReader scrolls to keep selected card visible
9. AccessibilityPromptView shows on first launch when permission not granted
10. AccessibilityPromptView auto-dismisses when permission is granted (polling)
11. "Skip for Now" dismisses the prompt without granting permission
12. All Phase 3 requirements covered: PAST-01 (double-click), PAST-02 (accessibility prompt), PAST-03 (non-activating -- verified by panel architecture), PNUI-04 (global hotkey -- already working), PNUI-09 (arrow keys + Enter)
</verification>

<success_criteria>
- User can navigate cards with up/down arrow keys
- Selected card is visually highlighted with accentColor background + border
- User can press Enter to paste the selected card
- User can double-click any card to paste it
- Panel dismisses after paste action (handled by PasteService calling panelController.hide())
- Selection resets when panel is re-shown
- On first launch without permission, user sees accessibility onboarding
- Onboarding explains purpose, offers grant/settings/skip options
- Onboarding auto-dismisses when permission is granted
- All 5 Phase 3 requirements (PAST-01, PAST-02, PAST-03, PNUI-04, PNUI-09) are satisfied
- Project compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-paste-back-and-hotkeys/03-02-SUMMARY.md`
</output>
