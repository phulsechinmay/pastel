---
phase: 18-codebase-audit-anti-patterns-performance-and-security-encryption
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Pastel/Services/ImageStorageService.swift
  - Pastel/Extensions/PersistentIdentifier+Transfer.swift
  - Pastel/Views/Panel/PanelContentView.swift
  - Pastel/Services/ImportExportService.swift
autonomous: true

must_haves:
  truths:
    - "No force unwraps (!) remain in ImageStorageService.swift, PersistentIdentifier+Transfer.swift, or PanelContentView.swift (except PastelApp.swift fatalError which is acceptable)"
    - "PersistentIdentifier.asTransferString returns String? (optional) and all callers handle nil gracefully"
    - "Import of 1000+ items uses a pre-loaded Set<String> of content hashes instead of per-item SwiftData queries"
  artifacts:
    - path: "Pastel/Extensions/PersistentIdentifier+Transfer.swift"
      provides: "Safe encoding with optional return type"
      contains: "var asTransferString: String?"
    - path: "Pastel/Services/ImportExportService.swift"
      provides: "Batch-optimized import with pre-loaded hash set"
      contains: "Set<String>"
  key_links:
    - from: "Pastel/Views/Panel/FilteredCardListView.swift"
      to: "Pastel/Extensions/PersistentIdentifier+Transfer.swift"
      via: "asTransferString used in DragItemProviderService and drop targets"
      pattern: "asTransferString"
    - from: "Pastel/Services/ImportExportService.swift"
      to: "SwiftData ClipboardItem model"
      via: "Pre-loaded hash set replaces per-item fetchCount query"
      pattern: "existingHashes"
---

<objective>
Fix force unwraps that pose crash risks in three files and optimize the import loop to use batch hash pre-loading instead of per-item database queries.

Purpose: Eliminate crash-risk force unwraps (A1) that could cause unexpected termination during drag-and-drop or app initialization, and improve import performance (P2) for large datasets from O(n) database queries to O(1) in-memory lookups.

Output: Safe unwrap patterns in 3 files, optional return type on PersistentIdentifier.asTransferString, batch-optimized import in ImportExportService.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-codebase-audit-anti-patterns-performance-and-security-encryption/18-RESEARCH.md

Source files to modify:
@Pastel/Services/ImageStorageService.swift
@Pastel/Extensions/PersistentIdentifier+Transfer.swift
@Pastel/Views/Panel/PanelContentView.swift
@Pastel/Services/ImportExportService.swift

Files that call asTransferString (check for callers that need updating):
@Pastel/Views/Panel/ChipBarView.swift
@Pastel/Services/DragItemProviderService.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace force unwraps with safe alternatives in three files</name>
  <files>
    Pastel/Services/ImageStorageService.swift
    Pastel/Extensions/PersistentIdentifier+Transfer.swift
    Pastel/Views/Panel/PanelContentView.swift
  </files>
  <action>
    **ImageStorageService.swift (line 46): `.first!` on applicationSupportDirectory**

    Replace the force unwrap with a guard-let that falls back to fatalError with a clear message. This directory truly should always exist on macOS, so fatalError is acceptable (same pattern as PastelApp.swift ModelContainer), but the error message will be descriptive:

    ```swift
    // BEFORE:
    let appSupport = FileManager.default.urls(
        for: .applicationSupportDirectory,
        in: .userDomainMask
    ).first!

    // AFTER:
    guard let appSupport = FileManager.default.urls(
        for: .applicationSupportDirectory,
        in: .userDomainMask
    ).first else {
        fatalError("Application Support directory unavailable")
    }
    ```

    **PersistentIdentifier+Transfer.swift (lines 7-8): `try!` and `.utf8!`**

    Change `asTransferString` from `String` to `String?` (optional). This is the most impactful change because callers must handle nil:

    ```swift
    // BEFORE:
    var asTransferString: String {
        let data = try! JSONEncoder().encode(self)
        return String(data: data, encoding: .utf8)!
    }

    // AFTER:
    var asTransferString: String? {
        guard let data = try? JSONEncoder().encode(self),
              let string = String(data: data, encoding: .utf8) else {
            return nil
        }
        return string
    }
    ```

    After changing the return type, find ALL callers of `asTransferString` and update them to handle the optional. Use `grep -r "asTransferString" Pastel/ --include="*.swift"` to find all call sites. Expected callers:
    - `ChipBarView.swift`: Used in `.onDrag { NSItemProvider(object: label.persistentModelID.asTransferString as NSString) }` -- guard with `if let` or use `?? ""` (empty string means the drag will fail gracefully at the drop target's decode step).
    - `DragItemProviderService.swift`: May use it for drag providers -- same pattern, guard or nil-coalesce.

    For drag-and-drop callers, the safest pattern is to return an empty `NSItemProvider()` if encoding fails:
    ```swift
    // Example fix for .onDrag:
    .onDrag {
        guard let transferString = label.persistentModelID.asTransferString else {
            return NSItemProvider()
        }
        return NSItemProvider(object: transferString as NSString)
    }
    ```

    **PanelContentView.swift (line 199): `labelIDs.first!`**

    The force unwrap at line 199 is inside `cycleLabelFilter(direction:)` and is guarded by `guard !labels.isEmpty`. However, `labelIDs` is derived from `labels.map(\.persistentModelID)`, so if labels is non-empty, labelIDs is also non-empty. The guard is sufficient but replace the force unwrap with a safe alternative for defensive coding:

    ```swift
    // BEFORE:
    if direction > 0 {
        selectedLabelIDs = [labelIDs.first!]
    } else {
        selectedLabelIDs = [labelIDs.last!]
    }

    // AFTER:
    if direction > 0 {
        if let firstID = labelIDs.first {
            selectedLabelIDs = [firstID]
        }
    } else {
        if let lastID = labelIDs.last {
            selectedLabelIDs = [lastID]
        }
    }
    ```
  </action>
  <verify>
    Build: `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild build -scheme Pastel -destination 'platform=macOS' -quiet 2>&1 | tail -5`
    Verify no force unwraps in target files: `grep -n 'try!\|\.first!\|\.last!\|\.utf8!' Pastel/Services/ImageStorageService.swift Pastel/Extensions/PersistentIdentifier+Transfer.swift Pastel/Views/Panel/PanelContentView.swift` should return nothing.
    Verify optional return type: `grep "var asTransferString: String?" Pastel/Extensions/PersistentIdentifier+Transfer.swift` should return 1 match.
  </verify>
  <done>
    All force unwraps replaced with safe alternatives. `PersistentIdentifier.asTransferString` returns `String?`. All callers handle nil gracefully. Build succeeds with no warnings related to these changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Optimize import deduplication with pre-loaded content hash set</name>
  <files>Pastel/Services/ImportExportService.swift</files>
  <action>
    In `ImportExportService.importHistory(from:modelContext:)`, the current implementation runs a separate SwiftData `fetchCount` query for every imported item to check for duplicates (lines 222-228). For large imports (1000+ items), this is O(n) database queries.

    Optimize by pre-loading all existing content hashes into a `Set<String>` before the import loop:

    ```swift
    // ADD before the import loop (after "Phase 2: Item import" comment, around line 215):
    // Pre-load all existing content hashes for O(1) dedup lookups
    let allItemsDescriptor = FetchDescriptor<ClipboardItem>()
    let existingItems = try modelContext.fetch(allItemsDescriptor)
    var existingHashes = Set<String>(existingItems.map(\.contentHash))

    // REPLACE the per-item hash check inside the loop:
    // BEFORE (lines 221-228):
    let hash = exportedItem.contentHash
    let checkDescriptor = FetchDescriptor<ClipboardItem>(
        predicate: #Predicate<ClipboardItem> { item in
            item.contentHash == hash
        }
    )
    if (try? modelContext.fetchCount(checkDescriptor)) ?? 0 > 0 {

    // AFTER:
    let hash = exportedItem.contentHash
    if existingHashes.contains(hash) {
    ```

    Also, after inserting a new item, add its hash to the set so that duplicates within the import file itself are caught:
    ```swift
    // After modelContext.insert(item):
    modelContext.insert(item)
    existingHashes.insert(hash)
    importedCount += 1
    ```

    This changes the dedup from O(n) database queries to 1 database query + O(n) in-memory Set lookups. The tradeoff is loading all ClipboardItem objects into memory once, but this is acceptable because:
    1. The import already loads all imported items into memory
    2. Typical clipboard histories are <10K items
    3. We only need the contentHash field (though SwiftData loads full objects)

    Do NOT change the batch save logic (every 50 items) or the final save -- those remain unchanged.
  </action>
  <verify>
    Build: `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild build -scheme Pastel -destination 'platform=macOS' -quiet 2>&1 | tail -5`
    Verify pre-loaded hash set: `grep "existingHashes" Pastel/Services/ImportExportService.swift` should return matches.
    Verify no per-item fetchCount in import loop: `grep "fetchCount(checkDescriptor)" Pastel/Services/ImportExportService.swift` should return nothing.
  </verify>
  <done>
    Import deduplication uses pre-loaded Set<String> of content hashes instead of per-item SwiftData queries. Within-file duplicates are also caught via set insertion. Build succeeds.
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild build -scheme Pastel -destination 'platform=macOS' -quiet` succeeds
2. `grep -rn 'try!\|\.first!\|\.last!\|\.utf8!' Pastel/Services/ImageStorageService.swift Pastel/Extensions/PersistentIdentifier+Transfer.swift Pastel/Views/Panel/PanelContentView.swift` returns nothing
3. `grep "existingHashes" Pastel/Services/ImportExportService.swift` returns matches
4. `grep "fetchCount" Pastel/Services/ImportExportService.swift` returns nothing (the per-item query is gone)
</verification>

<success_criteria>
- Zero force unwraps in ImageStorageService, PersistentIdentifier+Transfer, PanelContentView
- PersistentIdentifier.asTransferString returns String? and all callers handle nil
- Import uses batch hash pre-loading (Set<String>) not per-item queries
- Build compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/18-codebase-audit-anti-patterns-performance-and-security-encryption/18-02-SUMMARY.md`
</output>
