---
phase: 08-url-preview-cards
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Pastel/Services/URLMetadataService.swift
  - Pastel/Services/ImageStorageService.swift
  - Pastel/Services/ClipboardMonitor.swift
autonomous: true

must_haves:
  truths:
    - "User copies a URL and the item's urlTitle, urlFaviconPath, and urlPreviewImagePath fields are populated within seconds"
    - "User copies a private/local URL (localhost, 192.168.x.x) and no metadata fetch is attempted"
    - "User copies a URL while offline and the item falls back gracefully (urlMetadataFetched = false)"
    - "User copies a duplicate URL and metadata is reused from the previous entry without a network call"
    - "User copies a URL with the fetch toggle disabled and no metadata fetch is attempted"
  artifacts:
    - path: "Pastel/Services/URLMetadataService.swift"
      provides: "URL metadata fetching via LPMetadataProvider with 5s timeout, private URL skip, duplicate reuse"
      min_lines: 80
    - path: "Pastel/Services/ImageStorageService.swift"
      provides: "saveFavicon and savePreviewImage methods for URL metadata images"
    - path: "Pastel/Services/ClipboardMonitor.swift"
      provides: "Fire-and-forget async URL metadata fetch after URL item save"
  key_links:
    - from: "Pastel/Services/ClipboardMonitor.swift"
      to: "Pastel/Services/URLMetadataService.swift"
      via: "fire-and-forget Task after URL item save"
      pattern: "URLMetadataService.*fetch"
    - from: "Pastel/Services/URLMetadataService.swift"
      to: "Pastel/Services/ImageStorageService.swift"
      via: "saves favicon and og:image to disk"
      pattern: "ImageStorageService.*save(Favicon|PreviewImage)"
    - from: "Pastel/Services/URLMetadataService.swift"
      to: "LPMetadataProvider"
      via: "Apple LinkPresentation framework"
      pattern: "LPMetadataProvider"
---

<objective>
Create URLMetadataService that auto-fetches page metadata (title, favicon, og:image) for URL clipboard items, with disk caching for images and fire-and-forget integration into ClipboardMonitor.

Purpose: Enables rich URL preview cards by providing the metadata backend. Without this service, URL cards remain plain text with a globe icon.

Output: URLMetadataService.swift (new), updated ImageStorageService.swift (favicon/og:image save methods), updated ClipboardMonitor.swift (async metadata fetch wiring).
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-url-preview-cards/08-CONTEXT.md

Key source files:
@Pastel/Models/ClipboardItem.swift — Already has urlTitle, urlFaviconPath, urlPreviewImagePath, urlMetadataFetched fields (added in Phase 6)
@Pastel/Services/ClipboardMonitor.swift — Fire-and-forget pattern established for code language detection (line ~269-278)
@Pastel/Services/ImageStorageService.swift — Existing disk image storage with background queue
@Pastel/Services/ColorDetectionService.swift — Static service pattern reference
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create URLMetadataService with LPMetadataProvider</name>
  <files>
    Pastel/Services/URLMetadataService.swift
    Pastel/Services/ImageStorageService.swift
  </files>
  <action>
  Create `Pastel/Services/URLMetadataService.swift` as a struct with static methods (matching ColorDetectionService pattern):

  **URLMetadataService.swift:**

  1. `static func shouldFetchMetadata(for urlString: String) -> Bool`
     - Return false if the @AppStorage "fetchURLMetadata" is false (read from UserDefaults.standard)
     - Parse urlString into a URL. Return false if parsing fails.
     - Return false if scheme is NOT http or https (skip file://, ftp://, custom schemes)
     - Return false if host is localhost, 127.0.0.1, or matches private IP ranges: 192.168.x.x, 10.x.x.x, 172.16-31.x.x, [::1], fe80::
     - Return true otherwise

  2. `static func fetchMetadata(for urlString: String, itemID: PersistentModelID, modelContext: ModelContext) async`
     - This is the main entry point called from ClipboardMonitor's fire-and-forget Task
     - Guard: call shouldFetchMetadata, return early if false
     - Guard: parse urlString into URL
     - Check for duplicate: query SwiftData for another ClipboardItem with same textContent, urlMetadataFetched == true, that is NOT the current itemID. If found, copy its urlTitle, urlFaviconPath, urlPreviewImagePath, urlMetadataFetched to the current item and save. Return early.
     - Create LPMetadataProvider() (import LinkPresentation)
     - Set provider.timeout = 5.0 (5-second timeout per CONTEXT.md decision)
     - Use `try await provider.startFetchingMetadata(for: url)` wrapped in do/catch
     - On success: extract metadata.title, metadata.iconProvider (favicon), metadata.imageProvider (og:image)
     - Use NSItemProvider's `loadDataRepresentation(for: .image)` to get Data from icon and image providers
     - Save favicon to disk via `ImageStorageService.shared.saveFavicon(data:)` -> returns filename
     - Save og:image to disk via `ImageStorageService.shared.savePreviewImage(data:)` -> returns filename
     - Update the ClipboardItem: urlTitle = metadata.title, urlFaviconPath = faviconFilename, urlPreviewImagePath = previewImageFilename, urlMetadataFetched = true
     - Save modelContext
     - On failure (catch): set urlMetadataFetched = false on the item, save. Log warning.
     - Use OSLog Logger (subsystem: Bundle.main.bundleIdentifier, category: "URLMetadataService")

  **Important implementation details:**
  - LPMetadataProvider is NOT Sendable. Create it inside the async method body, not as a stored property.
  - NSItemProvider loadDataRepresentation needs a continuation wrapper for async/await usage. Use `withCheckedContinuation` or `withCheckedThrowingContinuation`.
  - The modelContext operations must happen on @MainActor. Mark the fetchMetadata method appropriately or use MainActor.run { } for the SwiftData operations.
  - The `shouldFetchMetadata` function reads UserDefaults directly (not @AppStorage, since this is a service, not a view).

  **ImageStorageService.swift additions:**

  Add two new public methods (similar to saveImage but simpler -- no downscaling, no thumbnail):

  3. `func saveFavicon(data: Data) -> String?`
     - Synchronous save on backgroundQueue (use DispatchQueue sync or move to async pattern)
     - Actually, to keep it simple and match the existing async pattern: use a completion handler OR make it async.
     - Recommended: Add an async wrapper. `func saveFavicon(data: Data) async -> String?`
     - Generate UUID filename: `{UUID}_favicon.png`
     - Write data to imagesDirectory/filename
     - Return filename on success, nil on failure
     - Log via existing logger

  4. `func savePreviewImage(data: Data) async -> String?`
     - Same pattern as saveFavicon
     - Generate UUID filename: `{UUID}_preview.png`
     - Downscale if larger than 1920px wide (og:images can be large) using existing downscaleIfNeeded with maxSize 1920
     - Write to imagesDirectory/filename
     - Return filename on success, nil on failure

  Both methods should use `withCheckedContinuation` wrapping backgroundQueue.async for the actual disk I/O.
  </action>
  <verify>
  Build succeeds: `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild -project Pastel.xcodeproj -scheme Pastel -configuration Debug build 2>&1 | tail -5`

  Check URLMetadataService exists and has required methods:
  - grep for "shouldFetchMetadata" in URLMetadataService.swift
  - grep for "fetchMetadata" in URLMetadataService.swift
  - grep for "LPMetadataProvider" in URLMetadataService.swift
  - grep for "saveFavicon" in ImageStorageService.swift
  - grep for "savePreviewImage" in ImageStorageService.swift
  </verify>
  <done>
  URLMetadataService.swift exists with shouldFetchMetadata (private URL skip, scheme check, settings check) and fetchMetadata (LPMetadataProvider with 5s timeout, duplicate reuse, favicon/og:image disk save). ImageStorageService has saveFavicon and savePreviewImage methods. Build compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire URLMetadataService into ClipboardMonitor</name>
  <files>
    Pastel/Services/ClipboardMonitor.swift
  </files>
  <action>
  In ClipboardMonitor.swift, add fire-and-forget URL metadata fetching after a URL item is saved. Follow the exact same pattern as the existing code language detection (lines ~269-278).

  In `processPasteboardContent()`, after the `try modelContext.save()` success block, after the existing code detection fire-and-forget Task, add:

  ```swift
  // Fire-and-forget async URL metadata fetch for URL items
  if detectedContentType == .url {
      let itemID = item.persistentModelID
      let urlString = primaryContent
      let ctx = self.modelContext
      Task {
          await URLMetadataService.fetchMetadata(
              for: urlString,
              itemID: itemID,
              modelContext: ctx
          )
      }
  }
  ```

  This mirrors the code detection pattern: save the item first (so it appears in the panel immediately as a plain URL card), then asynchronously enrich it with metadata. The SwiftData change will trigger SwiftUI @Query updates, causing the card to re-render with the fetched metadata.

  **Important:** The modelContext is @MainActor-isolated (ClipboardMonitor is @MainActor). The URLMetadataService.fetchMetadata must handle this correctly -- either accept the context and do MainActor.run for SwiftData ops, or accept the itemID and create its own fetch pattern. The simplest approach: pass modelContext directly since ClipboardMonitor is already @MainActor and the Task inherits that context.
  </action>
  <verify>
  Build succeeds: `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild -project Pastel.xcodeproj -scheme Pastel -configuration Debug build 2>&1 | tail -5`

  Verify wiring exists:
  - grep for "URLMetadataService" in ClipboardMonitor.swift
  - grep for "fetchMetadata" in ClipboardMonitor.swift
  </verify>
  <done>
  ClipboardMonitor fires async URL metadata fetch after saving URL items. Pattern matches existing code detection fire-and-forget. Build compiles cleanly. Copying a URL will trigger metadata fetch that populates urlTitle, urlFaviconPath, urlPreviewImagePath on the ClipboardItem.
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild -project Pastel.xcodeproj -scheme Pastel -configuration Debug build` succeeds
2. URLMetadataService.swift exists at Pastel/Services/URLMetadataService.swift
3. URLMetadataService has shouldFetchMetadata (returns Bool) and fetchMetadata (async)
4. shouldFetchMetadata rejects: non-http(s) schemes, localhost, 127.0.0.1, 192.168.x.x, 10.x.x.x, 172.16-31.x.x
5. shouldFetchMetadata checks UserDefaults "fetchURLMetadata" toggle
6. fetchMetadata uses LPMetadataProvider with 5-second timeout
7. fetchMetadata handles duplicate URL reuse (query for existing metadata)
8. ImageStorageService has saveFavicon and savePreviewImage methods
9. ClipboardMonitor has fire-and-forget Task calling URLMetadataService.fetchMetadata for .url items
</verification>

<success_criteria>
- URLMetadataService created with LPMetadataProvider-based fetching, 5s timeout, private URL filtering, duplicate reuse
- ImageStorageService extended with favicon and og:image disk caching
- ClipboardMonitor wired to fire-and-forget metadata fetch on URL capture
- All SwiftData fields (urlTitle, urlFaviconPath, urlPreviewImagePath, urlMetadataFetched) populated correctly
- Build compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-url-preview-cards/08-01-SUMMARY.md`
</output>
