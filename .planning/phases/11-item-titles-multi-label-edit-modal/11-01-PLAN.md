---
phase: 11-item-titles-multi-label-edit-modal
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Pastel/Models/ClipboardItem.swift
  - Pastel/Models/Label.swift
  - Pastel/Services/MigrationService.swift
  - Pastel/PastelApp.swift
  - Pastel/Views/Panel/EditItemView.swift
autonomous: true

must_haves:
  truths:
    - "ClipboardItem has an optional title field and a labels array for many-to-many label assignment"
    - "Label has an items array as inverse of ClipboardItem.labels"
    - "Existing single-label assignments are migrated to the new labels array on first launch"
    - "EditItemView presents a sheet with title text field and label multi-select toggle chips"
  artifacts:
    - path: "Pastel/Models/ClipboardItem.swift"
      provides: "title: String? and labels: [Label] properties"
      contains: "var title: String?"
    - path: "Pastel/Models/Label.swift"
      provides: "Updated inverse relationship to ClipboardItem.labels"
      contains: "var items: [ClipboardItem]"
    - path: "Pastel/Services/MigrationService.swift"
      provides: "One-time migration from label to labels"
      contains: "migrateLabelsIfNeeded"
    - path: "Pastel/PastelApp.swift"
      provides: "Migration wired on launch after setup"
      contains: "MigrationService"
    - path: "Pastel/Views/Panel/EditItemView.swift"
      provides: "Edit modal with title field and label toggles"
      contains: "EditItemView"
  key_links:
    - from: "Pastel/PastelApp.swift"
      to: "Pastel/Services/MigrationService.swift"
      via: "migrateLabelsIfNeeded call after setup"
      pattern: "MigrationService\\.migrateLabelsIfNeeded"
    - from: "Pastel/Models/ClipboardItem.swift"
      to: "Pastel/Models/Label.swift"
      via: "@Relationship inverse on labels property"
      pattern: "@Relationship.*inverse.*Label\\.items"
---

<objective>
Add the `title` and `labels` properties to the ClipboardItem model, update Label's inverse relationship, create a one-time migration service to move existing single-label assignments into the new labels array, and build the EditItemView modal for editing item titles and label assignments.

Purpose: This is the foundation for Phase 11 -- all card layout, filtering, and UI changes depend on these model and view additions.
Output: Updated data models, MigrationService, EditItemView, and migration wired on app launch.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-item-titles-multi-label-edit-modal/11-RESEARCH.md

Key files to read before implementing:
@Pastel/Models/ClipboardItem.swift
@Pastel/Models/Label.swift
@Pastel/PastelApp.swift
@Pastel/Views/Panel/ChipBarView.swift (for CenteredFlowLayout reuse in EditItemView)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update data models and create migration service</name>
  <files>
    Pastel/Models/ClipboardItem.swift
    Pastel/Models/Label.swift
    Pastel/Services/MigrationService.swift
    Pastel/PastelApp.swift
  </files>
  <action>
**ClipboardItem.swift:**
1. Add `var title: String?` property (optional, nil default per decision [06-01] -- no VersionedSchema needed).
2. Add `@Relationship(deleteRule: .nullify, inverse: \Label.items) var labels: [Label]` property. Place it AFTER the existing `label` property. SwiftData auto-initializes arrays to `[]`.
3. Keep the existing `var label: Label?` property but add a `// DEPRECATED: Kept for migration. Remove in v1.3+.` comment. REMOVE the `@Relationship` attribute from `label` if it has one (it currently does not have an explicit one, just a plain `var`). Important: the old `label: Label?` must NOT have an explicit `@Relationship` attribute -- it should remain a plain stored property so it doesn't conflict with the new `labels` inverse.
4. Do NOT change the `init()` -- `title` defaults to nil and `labels` defaults to `[]` via SwiftData auto-initialization.

**Label.swift:**
1. Remove the `@Relationship(deleteRule: .nullify, inverse: \ClipboardItem.label)` attribute from `var items: [ClipboardItem]`.
2. Replace it with a plain `var items: [ClipboardItem]` (no @Relationship attribute). SwiftData will infer the inverse from ClipboardItem's `@Relationship(inverse: \Label.items)` on the `labels` property.
3. This avoids a conflict between the old `label` and new `labels` both trying to be inverses of `items`.

**MigrationService.swift (NEW):**
Create `Pastel/Services/MigrationService.swift`:
```swift
import SwiftData

@MainActor
final class MigrationService {
    static func migrateLabelsIfNeeded(modelContext: ModelContext) {
        let key = "hasCompletedLabelMigration"
        guard !UserDefaults.standard.bool(forKey: key) else { return }

        let descriptor = FetchDescriptor<ClipboardItem>()
        guard let items = try? modelContext.fetch(descriptor) else { return }

        for item in items {
            if let singleLabel = item.label {
                if !item.labels.contains(where: {
                    $0.persistentModelID == singleLabel.persistentModelID
                }) {
                    item.labels.append(singleLabel)
                }
                item.label = nil
            }
        }

        try? modelContext.save()
        UserDefaults.standard.set(true, forKey: key)
    }
}
```

**PastelApp.swift:**
Add migration call AFTER `state.setup(modelContext:)` and AFTER `state.setupPanel(modelContainer:)`, but BEFORE `state.handleFirstLaunch()`:
```swift
MigrationService.migrateLabelsIfNeeded(modelContext: container.mainContext)
```
This ensures SwiftData has completed its lightweight schema migration (adding the new properties) before we attempt to read/write them.
  </action>
  <verify>
Build the project with `xcodebuild -project Pastel.xcodeproj -scheme Pastel build 2>&1 | tail -20`. It should compile without errors. The new properties exist on the models and MigrationService is callable from PastelApp.
  </verify>
  <done>
ClipboardItem has `title: String?` and `labels: [Label]` with @Relationship inverse. Label has plain `var items: [ClipboardItem]`. MigrationService copies `label` to `labels` on first launch. PastelApp calls migration after setup. Project compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create EditItemView modal</name>
  <files>
    Pastel/Views/Panel/EditItemView.swift
  </files>
  <action>
Create `Pastel/Views/Panel/EditItemView.swift` -- a `.sheet()` modal for editing an item's title and label assignments.

**Structure:**
```swift
import SwiftUI
import SwiftData

struct EditItemView: View {
    @Bindable var item: ClipboardItem
    @Query(sort: \Label.sortOrder) private var allLabels: [Label]
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Edit Item")
                .font(.headline)

            // Title field
            TextField("Title (optional)", text: titleBinding)
                .textFieldStyle(.roundedBorder)

            // Label multi-select section
            if !allLabels.isEmpty {
                Text("Labels")
                    .font(.subheadline)
                    .foregroundStyle(.secondary)

                // Reuse CenteredFlowLayout from ChipBarView
                CenteredFlowLayout(horizontalSpacing: 6, verticalSpacing: 6) {
                    ForEach(allLabels) { label in
                        labelToggleChip(for: label)
                    }
                }
            }

            HStack {
                Spacer()
                Button("Done") { dismiss() }
                    .keyboardShortcut(.return, modifiers: [])
            }
        }
        .padding()
        .frame(width: 280)
    }
}
```

**Title binding** -- converts between optional String and TextField String:
```swift
private var titleBinding: Binding<String> {
    Binding(
        get: { item.title ?? "" },
        set: { newValue in
            let trimmed = newValue.trimmingCharacters(in: .whitespaces)
            item.title = trimmed.isEmpty ? nil : String(newValue.prefix(50))
        }
    )
}
```
Note: Enforce 50-char limit in the setter (per CONTEXT.md decision). Do NOT trim whitespace from the stored value on every keystroke -- only check emptiness. The `prefix(50)` silently truncates beyond 50 chars.

Actually, re-read the decision: "50 characters" limit. Enforce via `.onChange` or in the binding setter. Use `String(newValue.prefix(50))` in the setter. For the empty check, only set nil if the trimmed version is empty (so a title of spaces becomes nil). Store the raw prefix(50) otherwise.

Revised setter:
```swift
set: { newValue in
    let capped = String(newValue.prefix(50))
    item.title = capped.trimmingCharacters(in: .whitespaces).isEmpty ? nil : capped
}
```

**Label toggle chip:**
```swift
@ViewBuilder
private func labelToggleChip(for label: Label) -> some View {
    let isAssigned = item.labels.contains {
        $0.persistentModelID == label.persistentModelID
    }

    HStack(spacing: 4) {
        if let emoji = label.emoji, !emoji.isEmpty {
            Text(emoji)
                .font(.system(size: 10))
        } else {
            Circle()
                .fill(LabelColor(rawValue: label.colorName)?.color ?? .gray)
                .frame(width: 8, height: 8)
        }
        Text(label.name)
            .font(.caption)
            .lineLimit(1)
    }
    .padding(.horizontal, 8)
    .padding(.vertical, 4)
    .background(
        isAssigned
            ? Color.accentColor.opacity(0.3)
            : Color.white.opacity(0.1),
        in: Capsule()
    )
    .overlay(
        Capsule().strokeBorder(
            isAssigned ? Color.accentColor.opacity(0.6) : Color.clear,
            lineWidth: 1
        )
    )
    .contentShape(Capsule())
    .onTapGesture {
        if isAssigned {
            item.labels.removeAll {
                $0.persistentModelID == label.persistentModelID
            }
        } else {
            item.labels.append(label)
        }
    }
}
```

**Important:** `CenteredFlowLayout` is currently `private struct` inside ChipBarView.swift. It needs to be made non-private (remove `private` keyword) so EditItemView can use it. Update `ChipBarView.swift` line ~225 to change `private struct CenteredFlowLayout` to `struct CenteredFlowLayout`.

Also make sure to add the new file to the Xcode project. Since this is an Xcode project (not SPM), the file needs to be in the right group folder. Create the file at `Pastel/Views/Panel/EditItemView.swift`.

**Decision: Live editing (no save/cancel).** The @Bindable pattern means changes are written to SwiftData immediately. The "Done" button just dismisses. This matches the existing LabelSettingsView pattern.
  </action>
  <verify>
Build the project. EditItemView should compile. Verify CenteredFlowLayout is accessible (not private). The file must be added to the Xcode project target -- check with `grep -r "EditItemView" Pastel.xcodeproj/project.pbxproj` after adding.
  </verify>
  <done>
EditItemView.swift exists with title text field (50-char limit, nil when empty) and label multi-select toggle chips using CenteredFlowLayout. CenteredFlowLayout is no longer private. The modal uses @Bindable for live editing with a "Done" dismiss button.
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild -project Pastel.xcodeproj -scheme Pastel build` succeeds
2. ClipboardItem.swift contains `var title: String?` and `var labels: [Label]` with @Relationship
3. Label.swift has plain `var items: [ClipboardItem]` (no @Relationship attribute)
4. MigrationService.swift exists with UserDefaults-gated migration logic
5. PastelApp.swift calls `MigrationService.migrateLabelsIfNeeded` after setup
6. EditItemView.swift exists with title field and label toggle chips
7. CenteredFlowLayout is no longer private in ChipBarView.swift
</verification>

<success_criteria>
- Project compiles with new model properties, migration service, and edit modal view
- ClipboardItem supports both title and multiple labels
- Migration path exists for existing single-label data
- EditItemView is ready to be presented via .sheet() from other views
</success_criteria>

<output>
After completion, create `.planning/phases/11-item-titles-multi-label-edit-modal/11-01-SUMMARY.md`
</output>
