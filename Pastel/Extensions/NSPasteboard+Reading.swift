import AppKit
import UniformTypeIdentifiers

// MARK: - Custom PasteboardType Constants

extension NSPasteboard.PasteboardType {
    /// Marker type used by password managers to indicate concealed/sensitive content
    static let concealed = NSPasteboard.PasteboardType("org.nspasteboard.ConcealedType")

    /// Marker type indicating content should not be persisted to clipboard history
    static let transient = NSPasteboard.PasteboardType("org.nspasteboard.TransientType")

    /// Marker type indicating auto-generated content (e.g., auto-fill)
    static let autoGenerated = NSPasteboard.PasteboardType("org.nspasteboard.AutoGeneratedType")
}

// MARK: - Content Classification

extension NSPasteboard {

    /// Classifies the current pasteboard content into a ContentType with concealed flag.
    ///
    /// Returns nil if the pasteboard is empty, transient, or auto-generated (should be skipped entirely).
    /// Concealed content (from password managers) is still captured but flagged.
    ///
    /// Priority order (from research Pattern 2):
    /// 1. Image types (.tiff, .png)
    /// 2. File URL (check http/https -> .url, otherwise .file)
    /// 3. URL type
    /// 4. String (check URL pattern, then RTF/HTML -> .richText, else .text)
    func classifyContent() -> (contentType: ContentType, isConcealed: Bool)? {
        guard let types = self.types, !types.isEmpty else {
            return nil
        }

        // Skip transient and auto-generated content entirely
        if types.contains(.transient) || types.contains(.autoGenerated) {
            return nil
        }

        // Check for concealed marker (password managers) -- still capture but flag
        let isConcealed = types.contains(.concealed)

        // Priority 1: Image types
        if types.contains(.tiff) || types.contains(.png) {
            return (.image, isConcealed)
        }

        // Priority 2: File URL -- distinguish between web URLs and local files
        if types.contains(.fileURL) {
            if let urlString = self.string(forType: .fileURL),
               let url = URL(string: urlString) {
                let scheme = url.scheme?.lowercased() ?? ""
                if scheme == "http" || scheme == "https" {
                    return (.url, isConcealed)
                }
            }
            return (.file, isConcealed)
        }

        // Priority 3: URL type
        if types.contains(NSPasteboard.PasteboardType(rawValue: "public.url")) {
            return (.url, isConcealed)
        }

        // Priority 4: String-based classification
        if types.contains(.string) {
            // Check if the string is actually a URL
            if let text = self.string(forType: .string),
               let url = URL(string: text),
               let scheme = url.scheme?.lowercased(),
               (scheme == "http" || scheme == "https"),
               url.host != nil {
                return (.url, isConcealed)
            }

            // Check for rich text types
            if types.contains(.rtf) || types.contains(.html) {
                return (.richText, isConcealed)
            }

            return (.text, isConcealed)
        }

        return nil
    }

    // MARK: - Content Reading

    /// Reads text content from the pasteboard, including plain text, HTML, and RTF representations.
    ///
    /// Returns all available text representations for paste-back fidelity.
    func readTextContent() -> (text: String?, html: String?, rtfData: Data?, byteCount: Int) {
        let text = self.string(forType: .string)
        let html = self.string(forType: .html)
        let rtfData = self.data(forType: .rtf)

        // Calculate byte count from the largest representation
        var byteCount = 0
        if let textBytes = text?.utf8.count {
            byteCount = max(byteCount, textBytes)
        }
        if let htmlBytes = html?.utf8.count {
            byteCount = max(byteCount, htmlBytes)
        }
        if let rtfBytes = rtfData?.count {
            byteCount = max(byteCount, rtfBytes)
        }

        return (text, html, rtfData, byteCount)
    }

    /// Reads URL content from the pasteboard.
    ///
    /// Reads from .URL type first, then falls back to .string.
    /// Validates the content is actually an http/https URL.
    func readURLContent() -> (urlString: String?, byteCount: Int) {
        // Try reading from public.url type first
        var urlString = self.string(forType: NSPasteboard.PasteboardType(rawValue: "public.url"))

        // Fall back to .string
        if urlString == nil {
            urlString = self.string(forType: .string)
        }

        // Validate it's an http/https URL
        if let candidate = urlString,
           let url = URL(string: candidate),
           let scheme = url.scheme?.lowercased(),
           (scheme == "http" || scheme == "https") {
            return (candidate, candidate.utf8.count)
        }

        return (nil, 0)
    }

    /// Reads file reference content from the pasteboard.
    ///
    /// Reads from .fileURL type and returns the file path string.
    func readFileContent() -> (filePath: String?, byteCount: Int) {
        guard let urlString = self.string(forType: .fileURL),
              let url = URL(string: urlString) else {
            return (nil, 0)
        }

        let path = url.path
        return (path, path.utf8.count)
    }
}
