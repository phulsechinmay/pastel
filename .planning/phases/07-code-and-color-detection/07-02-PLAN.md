---
phase: 07-code-and-color-detection
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - Pastel/Services/CodeDetectionService.swift
  - Pastel/Services/ClipboardMonitor.swift
  - Pastel/Views/Panel/CodeCardView.swift
autonomous: false

must_haves:
  truths:
    - "HighlightSwift SPM package is added to the Xcode project and builds without errors"
    - "Code cards display syntax-highlighted text with a monospaced font and limited line count"
    - "Code cards show a language badge (e.g., 'Swift', 'Python') in the top-right area"
    - "Syntax highlighting uses a dark theme that fits the always-dark panel"
    - "Highlighted AttributedString is cached in memory so re-scrolling does not re-highlight"
    - "Language detection runs asynchronously after item save; card updates when detection completes"
  artifacts:
    - path: "Pastel/Views/Panel/CodeCardView.swift"
      provides: "Syntax-highlighted code preview card with language badge"
      contains: "CodeCardView"
    - path: "Pastel/Services/CodeDetectionService.swift"
      provides: "Async detectLanguage implementation using HighlightSwift"
      contains: "Highlight()"
  key_links:
    - from: "Pastel/Views/Panel/CodeCardView.swift"
      to: "HighlightSwift"
      via: "import HighlightSwift and Highlight().request() for syntax highlighting"
      pattern: "import HighlightSwift"
    - from: "Pastel/Services/ClipboardMonitor.swift"
      to: "Pastel/Services/CodeDetectionService.swift"
      via: "Fire-and-forget Task calling detectLanguage after item save"
      pattern: "CodeDetectionService\\.detectLanguage"
---

<objective>
Add HighlightSwift SPM dependency, implement async language detection in CodeDetectionService, create CodeCardView with syntax-highlighted previews and language badges, and wire fire-and-forget detection into ClipboardMonitor.

Purpose: This plan delivers requirements RICH-02 (syntax-highlighted previews) and RICH-03 (language badge). Without HighlightSwift, code cards would be plain text with no visual distinction.

Output: CodeCardView.swift with syntax highlighting and language badge; CodeDetectionService.detectLanguage implemented with HighlightSwift; ClipboardMonitor fires async detection after saving code items.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-code-and-color-detection/07-RESEARCH.md
@.planning/phases/07-code-and-color-detection/07-01-SUMMARY.md

@Pastel/Services/CodeDetectionService.swift
@Pastel/Services/ClipboardMonitor.swift
@Pastel/Models/ClipboardItem.swift
@Pastel/Views/Panel/TextCardView.swift
@Pastel/Views/Panel/ClipboardCardView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add HighlightSwift SPM and implement CodeDetectionService.detectLanguage + HighlightCache</name>
  <files>
    Pastel/Services/CodeDetectionService.swift
    Pastel/Services/ClipboardMonitor.swift
  </files>
  <action>
**Step 1: Add HighlightSwift SPM dependency.**

Add the package via `xcodebuild` or by editing the Xcode project:
- Package URL: `https://github.com/appstefan/HighlightSwift.git`
- Version rule: "Up to Next Major Version" from `1.1.0`
- Add `HighlightSwift` framework to the Pastel target

Use the `swift package` CLI or xcodebuild resolve. If the Xcode project file must be edited manually, use the Xcode GUI approach (File > Add Package Dependencies). Since this is an Xcode project (not Package.swift), you may need to:
1. Open the project.pbxproj and add the remote package reference, OR
2. Use `xcodebuild -resolvePackageDependencies` after adding to project settings

**Research finding:** HighlightSwift uses Swift tools 5.10. If there are Swift 6 concurrency warnings, use `@preconcurrency import HighlightSwift` in files that import it.

**Step 2: Implement CodeDetectionService.detectLanguage.**

Update CodeDetectionService.swift. Replace the stub `detectLanguage` method with:

```swift
import HighlightSwift  // or @preconcurrency import HighlightSwift if needed

static func detectLanguage(_ text: String) async -> (language: String, relevance: Int)? {
    let highlight = Highlight()
    do {
        let result = try await highlight.request(text)
        // Require relevance >= 5 to avoid false positives on short/ambiguous text
        guard result.relevance >= 5 else { return nil }
        return (result.language, result.relevance)
    } catch {
        return nil
    }
}
```

**Step 3: Add HighlightCache actor.**

Add to CodeDetectionService.swift (or a new section within it):

```swift
actor HighlightCache {
    static let shared = HighlightCache()
    private var cache: [String: AttributedString] = [:]  // contentHash -> highlighted

    func get(_ key: String) -> AttributedString? {
        cache[key]
    }

    func set(_ key: String, value: AttributedString) {
        cache[key] = value
        // Evict oldest entries if cache exceeds 200 items
        if cache.count > 200 {
            // Simple eviction: remove a random entry (no LRU needed at this scale)
            if let firstKey = cache.keys.first {
                cache.removeValue(forKey: firstKey)
            }
        }
    }
}
```

**Step 4: Wire fire-and-forget async detection into ClipboardMonitor.**

In ClipboardMonitor.processPasteboardContent(), after the item is saved (after `try modelContext.save()`) and inside the do block, add:

```swift
// Fire-and-forget async language detection for code items
if detectedContentType == .code {
    let textForDetection = primaryContent
    let itemID = item.persistentModelID
    Task.detached { [weak self] in
        guard let result = await CodeDetectionService.detectLanguage(textForDetection) else { return }
        await MainActor.run {
            guard let self else { return }
            // Re-fetch the item by ID to avoid stale reference
            if let existingItem = self.modelContext.model(for: itemID) as? ClipboardItem {
                existingItem.detectedLanguage = result.language
                try? self.modelContext.save()
            }
        }
    }
}
```

This pattern:
- Saves the item immediately as .code (from Plan 07-01's heuristic)
- Runs HighlightSwift detection on a background thread (Task.detached avoids MainActor)
- Updates detectedLanguage back on MainActor (SwiftData thread safety)
- Uses persistentModelID to safely re-fetch (not a stale model reference)
- If detection fails or relevance is too low, the item stays .code with nil detectedLanguage (CodeCardView handles this gracefully)
  </action>
  <verify>
Build succeeds with HighlightSwift resolved:
`cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild build -project Pastel.xcodeproj -scheme Pastel -destination 'platform=macOS' 2>&1 | tail -10`

Check that HighlightSwift is in resolved packages:
`ls /Users/phulsechinmay/Desktop/Projects/pastel/Pastel.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/`
  </verify>
  <done>
HighlightSwift is a resolved SPM dependency. CodeDetectionService.detectLanguage uses Highlight().request() with relevance >= 5 threshold. HighlightCache actor provides in-memory caching. ClipboardMonitor fires async language detection after saving code items.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CodeCardView with syntax highlighting and language badge</name>
  <files>
    Pastel/Views/Panel/CodeCardView.swift
  </files>
  <action>
Create a new SwiftUI view `CodeCardView` in `Pastel/Views/Panel/CodeCardView.swift`.

**Structure:**

```swift
import SwiftUI
import HighlightSwift  // or @preconcurrency if needed

struct CodeCardView: View {
    let item: ClipboardItem
    @AppStorage("panelEdge") private var panelEdgeRaw: String = PanelEdge.right.rawValue

    @State private var highlightedText: AttributedString?
    @State private var isHighlighting = false

    private var isHorizontal: Bool {
        let edge = PanelEdge(rawValue: panelEdgeRaw) ?? .right
        return !edge.isVertical
    }

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            // Language badge row (top-right aligned)
            if let language = item.detectedLanguage {
                HStack {
                    Spacer()
                    LanguageBadge(language: language)
                }
            }

            // Code preview with syntax highlighting
            if let highlighted = highlightedText {
                Text(highlighted)
                    .font(.system(size: 11, design: .monospaced))
                    .lineLimit(isHorizontal ? 10 : 6)
                    .frame(maxWidth: .infinity, alignment: .leading)
                    .textSelection(.enabled)
            } else {
                // Fallback: plain monospaced text while highlighting loads
                Text(item.textContent ?? "")
                    .font(.system(size: 11, design: .monospaced))
                    .lineLimit(isHorizontal ? 10 : 6)
                    .foregroundStyle(.primary)
                    .frame(maxWidth: .infinity, alignment: .leading)
            }
        }
        .task(id: item.contentHash) {
            await loadHighlighting()
        }
    }

    private func loadHighlighting() async {
        let cacheKey = item.contentHash

        // Check cache first
        if let cached = await HighlightCache.shared.get(cacheKey) {
            highlightedText = cached
            return
        }

        guard let text = item.textContent, !text.isEmpty else { return }

        let highlight = Highlight()
        do {
            let result: AttributedString
            if let language = item.detectedLanguage {
                // Use detected language for precise highlighting
                result = try await highlight.attributedText(
                    text,
                    language: language,
                    colors: .dark(.atomOne)
                )
            } else {
                // Auto-detect (fallback for items without detected language)
                let autoResult = try await highlight.request(text, colors: .dark(.atomOne))
                result = autoResult.attributedText
            }
            // Cache the result
            await HighlightCache.shared.set(cacheKey, value: result)
            highlightedText = result
        } catch {
            // Highlighting failed -- plain text fallback is already displayed
        }
    }
}

// MARK: - Language Badge

struct LanguageBadge: View {
    let language: String

    var body: some View {
        Text(displayName)
            .font(.system(size: 9, weight: .medium, design: .monospaced))
            .padding(.horizontal, 6)
            .padding(.vertical, 2)
            .background(Color.white.opacity(0.15), in: Capsule())
            .foregroundStyle(.secondary)
    }

    /// Capitalize first letter for display (e.g., "swift" -> "Swift")
    private var displayName: String {
        language.prefix(1).uppercased() + language.dropFirst()
    }
}
```

**Key design decisions:**
- Uses `.task(id: item.contentHash)` so highlighting re-runs only when content changes
- Monospaced font at size 11 (slightly smaller than TextCardView's .callout to fit more code)
- Line limit 6 for vertical panel, 10 for horizontal (code benefits from more lines)
- Language badge is a Capsule with secondary foreground and subtle white background
- If detectedLanguage is nil (detection pending or failed), still shows syntax-highlighted text via auto-detect
- HighlightCache prevents re-highlighting on scroll
- Theme: `.dark(.atomOne)` matches the always-dark panel aesthetic
- Plain text fallback shown immediately while async highlighting loads
  </action>
  <verify>
Build succeeds: `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild build -project Pastel.xcodeproj -scheme Pastel -destination 'platform=macOS' 2>&1 | tail -5`
  </verify>
  <done>
CodeCardView displays syntax-highlighted code with a language badge. Highlighting is async with in-memory caching. Falls back to plain monospaced text while loading. Adapts line count based on panel orientation.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
HighlightSwift SPM dependency added. CodeDetectionService now detects languages asynchronously via highlight.js. CodeCardView renders syntax-highlighted code previews with language badges. ClipboardMonitor fires async language detection after saving code items.

Note: CodeCardView is not yet routed in ClipboardCardView (that happens in Plan 07-03). To verify highlighting works, you can temporarily change the `.code` case in ClipboardCardView.contentPreview from `TextCardView(item: item)` to `CodeCardView(item: item)` -- or wait for Plan 07-03.
  </what-built>
  <how-to-verify>
1. Build and run the app
2. Open a text editor and copy a multi-line Swift function (e.g., a `func` with if/let/return and braces)
3. Open the panel (Cmd+Shift+V) and verify:
   - The card shows syntax-highlighted text with colors (not plain white text)
   - A language badge appears (e.g., "Swift") in a capsule
   - The text uses a monospaced font
4. Copy a Python snippet (e.g., `def hello():\n    print("hello")`) and verify it detects "Python"
5. Copy a plain English sentence and verify it remains a normal text card (no code highlighting)
6. If routing hasn't been updated yet (Plan 07-03), temporarily change the .code case in ClipboardCardView to route to CodeCardView to test
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. HighlightSwift builds without errors or concurrency warnings (or warnings are suppressed with @preconcurrency)
2. CodeDetectionService.detectLanguage returns language name and relevance for real code
3. CodeDetectionService.detectLanguage returns nil for prose (relevance < 5)
4. CodeCardView renders syntax-highlighted AttributedString with monospaced font
5. Language badge displays with capitalized language name
6. HighlightCache stores and retrieves AttributedStrings by content hash
7. ClipboardMonitor fires async Task.detached for language detection after saving .code items
8. No main thread blocking during detection (Task.detached ensures background execution)
</verification>

<success_criteria>
- HighlightSwift is a resolved SPM dependency in the Xcode project
- Code cards show syntax-highlighted previews with auto-detected language
- Language badge displays the detected language name
- Highlighting is cached and does not re-run on scroll
- Async detection does not block clipboard capture
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-code-and-color-detection/07-02-SUMMARY.md`
</output>
