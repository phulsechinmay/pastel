---
phase: 12-history-browser-and-bulk-actions
plan: 03
type: execute
wave: 3
depends_on: ["12-02"]
files_modified:
  - Pastel/Views/Settings/HistoryBrowserView.swift
  - Pastel/Views/Settings/HistoryGridView.swift
autonomous: true

must_haves:
  truths:
    - "User selects multiple items and clicks Copy to concatenate text content with newlines onto the clipboard"
    - "User selects multiple items and clicks Paste to copy concatenated text and simulate Cmd+V into the previously active app"
    - "User selects multiple items and clicks Delete to see a confirmation dialog showing number of items, then confirms to permanently delete them"
    - "Bottom action bar appears only when items are selected, showing item count and action buttons"
    - "After bulk delete, selection is cleared and grid updates to reflect removed items"
    - "Non-text items (images, files) are silently skipped during bulk copy/paste"
  artifacts:
    - path: "Pastel/Views/Settings/HistoryBrowserView.swift"
      provides: "Bottom action bar with Copy, Paste, Delete buttons and confirmation dialog"
      contains: "bulkCopy"
    - path: "Pastel/Views/Settings/HistoryGridView.swift"
      provides: "Exposed filteredItems accessor for parent to resolve selected items"
      contains: "filteredItems"
  key_links:
    - from: "Pastel/Views/Settings/HistoryBrowserView.swift"
      to: "NSPasteboard.general"
      via: "bulkCopy writes concatenated text to system pasteboard"
      pattern: "NSPasteboard\\.general"
    - from: "Pastel/Views/Settings/HistoryBrowserView.swift"
      to: "Pastel/Services/ImageStorageService.swift"
      via: "bulkDelete cleans up disk images before deleting items"
      pattern: "ImageStorageService\\.shared\\.deleteImage"
---

<objective>
Add bulk action toolbar with Copy, Paste, and Delete operations for selected items.

Purpose: Completes the History browser with the key user actions -- bulk copy (concatenate text with newlines), bulk paste (copy + simulate Cmd+V), and bulk delete (with confirmation dialog and image cleanup). This delivers all 6 success criteria for Phase 12.

Output: Bottom action bar with item count and three action buttons. All bulk operations functional with proper cleanup and feedback.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-history-browser-and-bulk-actions/12-RESEARCH.md
@.planning/phases/12-history-browser-and-bulk-actions/12-01-SUMMARY.md
@.planning/phases/12-history-browser-and-bulk-actions/12-02-SUMMARY.md

@Pastel/Views/Settings/HistoryBrowserView.swift
@Pastel/Views/Settings/HistoryGridView.swift
@Pastel/Services/PasteService.swift
@Pastel/Services/ImageStorageService.swift
@Pastel/App/AppState.swift
@Pastel/Models/ClipboardItem.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expose filteredItems from HistoryGridView for parent access</name>
  <files>
    Pastel/Views/Settings/HistoryGridView.swift
  </files>
  <action>
    The parent HistoryBrowserView needs to resolve selected PersistentIdentifiers into actual ClipboardItem objects for bulk operations. There are two approaches:

    **Preferred approach -- pass items back via binding or callback:**
    Add a callback closure to HistoryGridView that the parent can use to resolve items. Specifically, add an `onResolveItems` parameter or use a simpler pattern:

    Since HistoryBrowserView already holds `selectedIDs` and needs to resolve them to items, and HistoryGridView has the @Query results, the cleanest approach is:

    Add a `@Binding var resolvedItems: [ClipboardItem]` to HistoryGridView that gets updated whenever filteredItems changes:
    ```swift
    @Binding var resolvedItems: [ClipboardItem]
    ```
    In the body, add:
    ```swift
    .onChange(of: filteredItems.count) { _, _ in
        resolvedItems = filteredItems
    }
    .onAppear {
        resolvedItems = filteredItems
    }
    ```

    **Alternative (simpler):** Just pass `resolvedItems` binding and update it. The parent can then filter by selectedIDs.

    Update the init to accept the new binding:
    ```swift
    init(searchText: String, selectedLabelIDs: Set<PersistentIdentifier>, selectedIDs: Binding<Set<PersistentIdentifier>>, resolvedItems: Binding<[ClipboardItem]>) {
        // ... existing code ...
        _resolvedItems = resolvedItems
    }
    ```

    Also update `.onAppear` and add an `.onChange(of: items)` to keep resolvedItems in sync:
    ```swift
    .onAppear { resolvedItems = filteredItems }
    .onChange(of: items) { _, _ in resolvedItems = filteredItems }
    .onChange(of: selectedLabelIDs.count) { _, _ in resolvedItems = filteredItems }
    ```

    Wait -- there is a simpler pattern. Since the grid view is recreated via .id() when filters change, .onAppear fires each time. We just need .onAppear and .onChange(of: items) to cover new data arriving:
    ```swift
    .onAppear { resolvedItems = filteredItems }
    .onChange(of: items) { _, _ in resolvedItems = filteredItems }
    ```
  </action>
  <verify>
    HistoryGridView compiles with the new `resolvedItems` binding parameter. The binding updates when items change or when the view appears.
  </verify>
  <done>
    HistoryGridView exposes current filteredItems to the parent via a binding, enabling the parent to resolve selected IDs to actual ClipboardItem objects for bulk operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add bulk action toolbar with Copy, Paste, Delete to HistoryBrowserView</name>
  <files>
    Pastel/Views/Settings/HistoryBrowserView.swift
  </files>
  <action>
    Update HistoryBrowserView to add a bottom action bar that appears when items are selected, with Copy, Paste, and Delete buttons.

    **Add state:**
    ```swift
    @State private var resolvedItems: [ClipboardItem] = []
    @State private var showDeleteConfirmation = false
    @Environment(\.modelContext) private var modelContext
    @Environment(AppState.self) private var appState
    ```

    **Update HistoryGridView call** to pass `resolvedItems`:
    ```swift
    HistoryGridView(
        searchText: debouncedSearchText,
        selectedLabelIDs: selectedLabelIDs,
        selectedIDs: $selectedIDs,
        resolvedItems: $resolvedItems
    )
    ```

    **Add bottom action bar** below the grid (inside the VStack, after the Divider + grid):
    ```swift
    // Bottom action bar (visible when items are selected)
    if !selectedIDs.isEmpty {
        Divider()
        HStack(spacing: 16) {
            Text("\(selectedIDs.count) item\(selectedIDs.count == 1 ? "" : "s") selected")
                .font(.subheadline)
                .foregroundStyle(.secondary)

            Spacer()

            Button("Copy") {
                bulkCopy()
            }
            .buttonStyle(.bordered)

            Button("Paste") {
                bulkPaste()
            }
            .buttonStyle(.bordered)

            Button("Delete", role: .destructive) {
                showDeleteConfirmation = true
            }
            .buttonStyle(.bordered)
        }
        .padding(.horizontal, 16)
        .padding(.vertical, 10)
        .background(.ultraThinMaterial)
    }
    ```

    **Add the confirmation alert:**
    ```swift
    .alert("Delete \(selectedIDs.count) Items", isPresented: $showDeleteConfirmation) {
        Button("Delete", role: .destructive) {
            bulkDelete()
        }
        Button("Cancel", role: .cancel) {}
    } message: {
        Text("This will permanently delete \(selectedIDs.count) clipboard item\(selectedIDs.count == 1 ? "" : "s"). This action cannot be undone.")
    }
    ```

    **Implement bulkCopy():**
    ```swift
    private func bulkCopy() {
        let selected = resolvedItems.filter { selectedIDs.contains($0.persistentModelID) }
        let textParts = selected.compactMap { item -> String? in
            switch item.type {
            case .text, .richText, .url, .code, .color:
                return item.textContent
            case .image, .file:
                return nil  // Skip non-text items
            }
        }
        guard !textParts.isEmpty else { return }

        let concatenated = textParts.joined(separator: "\n")
        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.setString(concatenated, forType: .string)

        // Signal clipboard monitor to skip this change (self-paste loop prevention)
        appState.clipboardMonitor?.skipNextChange = true
    }
    ```

    **Implement bulkPaste():**
    Paste from the settings window context is different from the panel. The settings window is a regular activating NSWindow. For paste-back:
    1. Copy concatenated text to pasteboard (same as bulkCopy)
    2. Minimize/close the settings window so the previously-active app regains focus
    3. After a delay, simulate Cmd+V

    ```swift
    private func bulkPaste() {
        bulkCopy()  // First, copy to pasteboard

        // Find and hide the settings window
        if let settingsWindow = NSApp.windows.first(where: { $0.title == "Pastel Settings" }) {
            settingsWindow.miniaturize(nil)
        }

        // Simulate Cmd+V after delay (same 250ms as PasteService)
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.35) {
            // Simulate Cmd+V via CGEvent
            let source = CGEventSource(stateID: .combinedSessionState)
            let vKeyCode: CGKeyCode = 0x09
            let keyDown = CGEvent(keyboardEventSource: source, virtualKey: vKeyCode, keyDown: true)
            let keyUp = CGEvent(keyboardEventSource: source, virtualKey: vKeyCode, keyDown: false)
            keyDown?.flags = .maskCommand
            keyUp?.flags = .maskCommand
            keyDown?.post(tap: .cgSessionEventTap)
            keyUp?.post(tap: .cgSessionEventTap)
        }
    }
    ```

    Note: Use 350ms delay (slightly more than PasteService's 250ms) because the settings window minimize animation takes longer than the panel hide. Alternatively, use `orderOut(nil)` instead of `miniaturize(nil)` for instant hide:
    ```swift
    settingsWindow.orderOut(nil)
    ```
    Use `orderOut(nil)` for instant hide (better UX). The user can reopen settings from the menu bar.

    **Implement bulkDelete():**
    Follow the same pattern as AppState.clearAllHistory and ClipboardCardView.deleteItem:
    ```swift
    private func bulkDelete() {
        let itemsToDelete = resolvedItems.filter { selectedIDs.contains($0.persistentModelID) }
        for item in itemsToDelete {
            // Clean up disk images
            ImageStorageService.shared.deleteImage(
                imagePath: item.imagePath,
                thumbnailPath: item.thumbnailPath
            )
            ImageStorageService.shared.deleteImage(
                imagePath: item.urlFaviconPath,
                thumbnailPath: item.urlPreviewImagePath
            )
            item.labels.removeAll()  // Clear many-to-many before delete
            modelContext.delete(item)
        }
        try? modelContext.save()
        selectedIDs.removeAll()
    }
    ```

    **Import AppKit** at the top of the file for NSPasteboard and CGEvent access:
    ```swift
    import AppKit
    ```

    **Critical details:**
    - `self-paste loop prevention`: Call `appState.clipboardMonitor?.skipNextChange = true` after writing to pasteboard in bulkCopy. This prevents the clipboard monitor from re-capturing what was just copied.
    - `Many-to-many cleanup`: Call `item.labels.removeAll()` before `modelContext.delete(item)` for each item -- required because SwiftData batch delete cannot handle MTM relationships (established in Phase 11 clearAllHistory pattern).
    - `Image cleanup`: Delete both regular images (imagePath, thumbnailPath) and URL metadata images (urlFaviconPath, urlPreviewImagePath) from disk before deleting the model.
    - `Accessibility check`: For bulkPaste, check `AccessibilityService.isGranted` before simulating Cmd+V. If not granted, just do bulkCopy (user must Cmd+V manually).
  </action>
  <verify>
    `xcodebuild -scheme Pastel build 2>&1 | tail -5` compiles without errors.

    Test manually:
    1. Open Settings > History tab
    2. Cmd-click 3 text items -- bottom bar shows "3 items selected" with Copy, Paste, Delete buttons
    3. Click Copy -- open a text editor, Cmd+V -- see concatenated text with newline separators
    4. Click Delete -- confirmation dialog shows "Delete 3 Items" with count. Confirm -- items disappear from grid, selection cleared
    5. Select items including an image -- Copy -- only text content items are concatenated (image skipped)
    6. Select items, click Paste -- settings window hides, text pastes into previously active app
  </verify>
  <done>
    Bottom action bar appears when items are selected showing "N items selected" with Copy, Paste, Delete buttons. Copy concatenates text content with newlines. Paste copies and simulates Cmd+V after hiding settings window. Delete shows confirmation with item count, then permanently removes items with full cleanup (images, labels, model).
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild -scheme Pastel build` succeeds
2. Bottom bar appears when 1+ items selected, disappears when 0 selected
3. Bar shows correct item count with proper singular/plural
4. Copy: concatenates textContent of text/richText/url/code/color items with \n, skips image/file
5. Copy: writes to NSPasteboard.general and sets skipNextChange on clipboard monitor
6. Paste: copies to pasteboard, hides settings window, simulates Cmd+V after 350ms delay
7. Delete: shows confirmation dialog with exact item count
8. Delete: cleans up disk images (imagePath, thumbnailPath, urlFaviconPath, urlPreviewImagePath)
9. Delete: clears labels array before deleting each item (MTM cleanup)
10. Delete: clears selection after deletion
11. Grid updates immediately after bulk delete (items disappear)
</verification>

<success_criteria>
- Bulk Copy concatenates selected text items with \n and writes to pasteboard
- Bulk Paste copies to pasteboard + hides settings window + simulates Cmd+V
- Bulk Delete shows confirmation dialog with item count, then deletes with full cleanup
- Non-text items silently skipped during copy/paste
- Self-paste loop prevention (skipNextChange) on copy
- MTM label relationships cleared before item deletion
- Disk images cleaned up on delete
- Bottom bar shows/hides based on selection state
- All 6 Phase 12 success criteria satisfied end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/12-history-browser-and-bulk-actions/12-03-SUMMARY.md`
</output>
