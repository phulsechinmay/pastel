---
phase: 07-code-and-color-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Pastel/Services/ColorDetectionService.swift
  - Pastel/Services/CodeDetectionService.swift
  - Pastel/Services/ClipboardMonitor.swift
autonomous: true

must_haves:
  truths:
    - "Copying a standalone hex color (#FF5733 or #abc) classifies the item as .color with detectedColorHex populated"
    - "Copying rgb(255, 87, 51) or hsl(0, 100%, 50%) classifies the item as .color with correct hex"
    - "Copying a multi-line code snippet with keywords/braces classifies the item as .code with detectedLanguage populated"
    - "Copying plain prose remains .text (no false positive detection)"
    - "Copying a sentence containing #FF5733 remains .text (color requires standalone value)"
    - "Color detection runs before code detection so rgb() values are not misclassified as code"
    - "Concealed items are never classified as code or color"
  artifacts:
    - path: "Pastel/Services/ColorDetectionService.swift"
      provides: "Regex-based color detection for hex/rgb/rgba/hsl/hsla with hex normalization"
      contains: "detectColor"
    - path: "Pastel/Services/CodeDetectionService.swift"
      provides: "Multi-signal heuristic pre-filter + HighlightSwift async language detection"
      contains: "looksLikeCode"
    - path: "Pastel/Services/ClipboardMonitor.swift"
      provides: "Detection wiring in processPasteboardContent()"
      contains: "ColorDetectionService"
  key_links:
    - from: "Pastel/Services/ClipboardMonitor.swift"
      to: "Pastel/Services/ColorDetectionService.swift"
      via: "ColorDetectionService.detectColor() call in processPasteboardContent()"
      pattern: "ColorDetectionService\\.detectColor"
    - from: "Pastel/Services/ClipboardMonitor.swift"
      to: "Pastel/Services/CodeDetectionService.swift"
      via: "CodeDetectionService.looksLikeCode() + async detect() in processPasteboardContent()"
      pattern: "CodeDetectionService"
---

<objective>
Create ColorDetectionService and CodeDetectionService, then wire both into ClipboardMonitor so clipboard items are classified as .color or .code at capture time.

Purpose: This is the detection backbone for Phase 7. Without these services, code and color cards (Plans 07-02, 07-03) have nothing to display. Detection must be accurate (no false positives on prose) and fast (no clipboard capture latency).

Output: Two new service files and an updated ClipboardMonitor that classifies items as .color, .code, or leaves them as .text/.richText.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-code-and-color-detection/07-RESEARCH.md

@Pastel/Services/ClipboardMonitor.swift
@Pastel/Models/ClipboardItem.swift
@Pastel/Models/ContentType.swift
@Pastel/Extensions/NSPasteboard+Reading.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: ColorDetectionService and CodeDetectionService</name>
  <files>
    Pastel/Services/ColorDetectionService.swift
    Pastel/Services/CodeDetectionService.swift
  </files>
  <action>
Create two new service files:

**ColorDetectionService.swift:**
- Struct with a single static method: `static func detectColor(_ text: String) -> String?`
- Returns a 6-digit uppercase hex string (no `#` prefix) if the ENTIRE trimmed text is a standalone color value, nil otherwise
- Skip multi-line text (contains `\n`) -- not a standalone color value
- Match order: hex first, then rgb/rgba, then hsl/hsla
- **Hex matching:** Use Swift Regex with `wholeMatch` to match `#` followed by exactly 3 or 6 hex digits. Expand 3-digit (#RGB) to 6-digit (RRGGBB) by doubling each char. Return uppercased.
- **RGB/RGBA matching:** Match `rgb(R, G, B)` or `rgba(R, G, B, A)` with `wholeMatch`. Validate each component is 0-255. Convert to hex with `String(format: "%02X%02X%02X", r, g, b)`.
- **HSL/HSLA matching:** Match `hsl(H, S%, L%)` or `hsla(H, S%, L%, A)` with `wholeMatch`. Validate H is 0-360, S and L are 0-100. Implement proper HSL-to-RGB conversion (NOT NSColor HSB). The HSL formula:
  ```
  if S == 0: R = G = B = L
  else:
    q = L < 0.5 ? L * (1 + S) : L + S - L * S
    p = 2 * L - q
    R = hueToRGB(p, q, H + 1/3)
    G = hueToRGB(p, q, H)
    B = hueToRGB(p, q, H - 1/3)
  ```
  Where `hueToRGB(p, q, t)` normalizes t to [0,1], then: if t < 1/6 return p+(q-p)*6*t; if t < 1/2 return q; if t < 2/3 return p+(q-p)*(2/3-t)*6; else return p.
- All regex patterns must be anchored (use `wholeMatch` or `^...$`). This prevents matching hex values embedded in larger text.

**CodeDetectionService.swift:**
- Struct with two static methods:
  1. `static func looksLikeCode(_ text: String) -> Bool` -- fast synchronous heuristic pre-filter
  2. `static func detectLanguage(_ text: String) async -> (language: String, relevance: Int)?` -- async HighlightSwift detection (stub for now, returns nil; Plan 07-02 adds HighlightSwift dependency and implements this)

- **looksLikeCode heuristic** (score >= 3 signals to return true):
  - Require minimum 2 lines (single-line text is almost never meaningful code)
  - Signal 1 (+1): Punctuation density > 0.03 (count `{}()[];=<>` chars / total char count)
  - Signal 2 (+2): Contains programming keywords (func, def, class, import, return, if, for, while, let, var, const, public, private, static, void, #include, #import, function, async, await -- each with trailing space or at line start)
  - Signal 3 (+1): >30% of lines have consistent indentation (start with 2+ spaces or tab)
  - Signal 4 (+1): >20% of lines end with `;`, `{`, or `}` (after trimming whitespace)
  - Signal 5 (+1): Contains CamelCase identifiers (pattern: `[a-z][a-zA-Z]*[A-Z][a-zA-Z]*`) or snake_case (pattern: `[a-z]+_[a-z]+`)
  - Return `score >= 3`

Both services must be pure structs with static methods -- no state, no dependencies on SwiftData or MainActor. This keeps them testable and usable from any context.
  </action>
  <verify>
Both files compile. Run: `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild build -project Pastel.xcodeproj -scheme Pastel -destination 'platform=macOS' 2>&1 | tail -5`

Manual spot check: ColorDetectionService.detectColor("#FF5733") returns "FF5733"; detectColor("Hello #FF5733 world") returns nil; detectColor("rgb(255, 87, 51)") returns "FF5733"; detectColor("hsl(0, 100%, 50%)") returns "FF0000".
  </verify>
  <done>
ColorDetectionService detects standalone hex/rgb/rgba/hsl/hsla values and returns normalized 6-digit hex. CodeDetectionService.looksLikeCode returns true for multi-line code with sufficient signals and false for prose. CodeDetectionService.detectLanguage is a stub returning nil (awaiting HighlightSwift in 07-02).
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire detection into ClipboardMonitor</name>
  <files>
    Pastel/Services/ClipboardMonitor.swift
  </files>
  <action>
Modify `processPasteboardContent()` in ClipboardMonitor to run detection after text is read but before the item is inserted:

1. **Remove the early-return for .code/.color in the switch statement.** Currently lines 189-193 have `case .code, .color: return`. Delete this case -- classifyContent() never returns these types, but the exhaustive switch needs them. Instead, fall through to the text handling. Actually, since classifyContent() only returns .text/.richText/.url/.image/.file, these cases are dead code. Just remove them; the switch is still exhaustive because contentType is typed as ContentType. Wait -- the switch is on `contentType` which comes from `classifyContent()`. Since that function only returns the 5 base types and .code/.color are newer cases, keep them but handle them identically to .text (read text content). Change:
   ```swift
   case .code, .color:
       return
   ```
   to:
   ```swift
   case .code, .color:
       // These are never returned by classifyContent(), but handle defensively
       let result = pasteboard.readTextContent()
       textContent = result.text
       htmlContent = result.html
       rtfData = result.rtfData
       byteCount = result.byteCount
       primaryContent = result.text ?? ""
   ```

2. **Add detection logic after the `guard !primaryContent.isEmpty` line** (line 197) and before the source app capture (line 200). Insert:

   ```swift
   // --- Content detection: color first, then code ---
   var detectedContentType = contentType
   var detectedColorHex: String? = nil
   var detectedLanguage: String? = nil

   // Skip detection for concealed items (password managers)
   if !isConcealed {
       // Color detection first (prevents rgb() from matching as code)
       if let colorHex = ColorDetectionService.detectColor(primaryContent) {
           detectedContentType = .color
           detectedColorHex = colorHex
       }
       // Code detection only if not already classified as color, URL, image, or file
       else if (contentType == .text || contentType == .richText),
               CodeDetectionService.looksLikeCode(primaryContent) {
           detectedContentType = .code
           // Language detection is async -- will be wired in Plan 07-02
           // For now, detectedLanguage stays nil
       }
   }
   ```

3. **Update the ClipboardItem creation** to use the detected values. Change `contentType: contentType` to `contentType: detectedContentType` in the ClipboardItem init call. After the init and before `modelContext.insert(item)`, set:
   ```swift
   item.detectedColorHex = detectedColorHex
   item.detectedLanguage = detectedLanguage
   ```

4. **Update the logger message** to reflect the actual detected type: change `contentType.rawValue` to `detectedContentType.rawValue` in the logger.info call.

Key constraints:
- Detection runs synchronously on the main thread (both are fast: regex for color, heuristic for code)
- Color detection MUST run before code detection (rgb() contains code-like punctuation)
- Never detect concealed items as code or color (password manager content is sensitive)
- The fire-and-forget async language detection via HighlightSwift will be added in Plan 07-02
  </action>
  <verify>
Build succeeds: `cd /Users/phulsechinmay/Desktop/Projects/pastel && xcodebuild build -project Pastel.xcodeproj -scheme Pastel -destination 'platform=macOS' 2>&1 | tail -5`

Launch the app manually. Copy "#FF5733" from any text editor. Check that the item appears in the panel (it will still show as TextCardView since card routing is updated in Plan 07-03, but the item's contentType in the data model should be "color"). Copy a multi-line Swift function -- the item should be stored with contentType "code". Copy a normal sentence -- should remain "text".
  </verify>
  <done>
ClipboardMonitor runs ColorDetectionService and CodeDetectionService on every text capture. Color values are classified as .color with detectedColorHex populated. Code snippets passing the heuristic are classified as .code. Plain text remains .text. Detection order is color-first, code-second. Concealed items are never reclassified.
  </done>
</task>

</tasks>

<verification>
1. Build succeeds with zero errors
2. ColorDetectionService correctly parses: #RGB, #RRGGBB, rgb(), rgba(), hsl(), hsla()
3. ColorDetectionService rejects: embedded hex in prose, multi-line text, invalid ranges
4. CodeDetectionService.looksLikeCode returns true for multi-line code with keywords/indentation/braces
5. CodeDetectionService.looksLikeCode returns false for plain prose, URLs, single-line text
6. ClipboardMonitor sets contentType to .color and populates detectedColorHex for standalone color values
7. ClipboardMonitor sets contentType to .code for code snippets passing the heuristic
8. Concealed items are never reclassified
</verification>

<success_criteria>
- Two new service files exist and compile
- ClipboardMonitor integrates both services in the correct order (color first, code second)
- No false positives: prose and embedded color values remain .text
- No false negatives: standalone hex/rgb/hsl values are detected as .color
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/07-code-and-color-detection/07-01-SUMMARY.md`
</output>
