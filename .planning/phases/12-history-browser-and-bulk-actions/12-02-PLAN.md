---
phase: 12-history-browser-and-bulk-actions
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - Pastel/Views/Settings/HistoryGridView.swift
  - Pastel/Views/Settings/HistoryBrowserView.swift
autonomous: true

must_haves:
  truths:
    - "User sees clipboard cards in a responsive grid that reflows columns when window is resized"
    - "User Cmd-clicks cards to toggle individual selection with visual highlight"
    - "User Shift-clicks to select a range of cards from the last-clicked card"
    - "User presses Cmd+A to select all visible cards and Escape to deselect all"
    - "Search field filters grid items in real time"
    - "Label chip bar filters grid items by selected labels"
  artifacts:
    - path: "Pastel/Views/Settings/HistoryGridView.swift"
      provides: "LazyVGrid with @Query, in-memory label filtering, multi-selection state"
      min_lines: 100
    - path: "Pastel/Views/Settings/HistoryBrowserView.swift"
      provides: "Updated root view composing HistoryGridView with search + chips + .id() recreation"
      contains: "HistoryGridView"
  key_links:
    - from: "Pastel/Views/Settings/HistoryBrowserView.swift"
      to: "Pastel/Views/Settings/HistoryGridView.swift"
      via: "HistoryGridView init with searchText and selectedLabelIDs, plus .id() modifier"
      pattern: "HistoryGridView.*searchText.*selectedLabelIDs"
    - from: "Pastel/Views/Settings/HistoryGridView.swift"
      to: "Pastel/Views/Panel/ClipboardCardView.swift"
      via: "ClipboardCardView instantiation inside ForEach"
      pattern: "ClipboardCardView\\(item:"
---

<objective>
Build the responsive card grid with multi-selection for the History tab.

Purpose: This is the core of the History browser -- a LazyVGrid that displays clipboard cards in a responsive layout with Cmd-click toggle, Shift-click range, and Cmd+A/Escape keyboard shortcuts for selection management.

Output: HistoryGridView with adaptive grid, @Query-based data, in-memory label filtering, and full multi-selection. HistoryBrowserView updated to compose it.
</objective>

<execution_context>
@/Users/phulsechinmay/.claude/get-shit-done/workflows/execute-plan.md
@/Users/phulsechinmay/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-history-browser-and-bulk-actions/12-RESEARCH.md
@.planning/phases/12-history-browser-and-bulk-actions/12-01-SUMMARY.md

@Pastel/Views/Panel/FilteredCardListView.swift
@Pastel/Views/Panel/ClipboardCardView.swift
@Pastel/Views/Panel/PanelContentView.swift
@Pastel/Views/Settings/HistoryBrowserView.swift
@Pastel/Models/ClipboardItem.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HistoryGridView with adaptive grid, @Query, and multi-selection</name>
  <files>
    Pastel/Views/Settings/HistoryGridView.swift
  </files>
  <action>
    Create `Pastel/Views/Settings/HistoryGridView.swift`. This follows the same init-based @Query pattern as FilteredCardListView but uses LazyVGrid instead of LazyVStack and adds multi-selection.

    **Structure:**
    ```swift
    import SwiftUI
    import SwiftData

    struct HistoryGridView: View {
        @Query private var items: [ClipboardItem]
        @Environment(\.modelContext) private var modelContext

        // Multi-selection state
        @Binding var selectedIDs: Set<PersistentIdentifier>
        @State private var lastClickedID: PersistentIdentifier? = nil

        // Label filtering (in-memory, same reason as FilteredCardListView)
        private let selectedLabelIDs: Set<PersistentIdentifier>

        private let columns = [
            GridItem(.adaptive(minimum: 280, maximum: 400), spacing: 12)
        ]

        init(searchText: String, selectedLabelIDs: Set<PersistentIdentifier>, selectedIDs: Binding<Set<PersistentIdentifier>>) {
            self.selectedLabelIDs = selectedLabelIDs
            _selectedIDs = selectedIDs

            let predicate: Predicate<ClipboardItem>
            if !searchText.isEmpty {
                let search = searchText
                predicate = #Predicate<ClipboardItem> { item in
                    item.textContent?.localizedStandardContains(search) == true ||
                    item.sourceAppName?.localizedStandardContains(search) == true ||
                    item.title?.localizedStandardContains(search) == true
                }
            } else {
                predicate = #Predicate<ClipboardItem> { _ in true }
            }

            _items = Query(filter: predicate, sort: \ClipboardItem.timestamp, order: .reverse)
        }
    }
    ```

    **Computed property for in-memory label filtering (same pattern as FilteredCardListView):**
    ```swift
    private var filteredItems: [ClipboardItem] {
        guard !selectedLabelIDs.isEmpty else { return items }
        return items.filter { item in
            item.labels.contains { label in
                selectedLabelIDs.contains(label.persistentModelID)
            }
        }
    }
    ```

    **Body -- LazyVGrid with adaptive columns:**
    ```swift
    var body: some View {
        Group {
            if filteredItems.isEmpty {
                VStack(spacing: 8) {
                    Image(systemName: "clock.arrow.circlepath")
                        .font(.system(size: 32))
                        .foregroundStyle(.tertiary)
                    Text("No items found")
                        .font(.subheadline)
                        .foregroundStyle(.secondary)
                }
                .frame(maxWidth: .infinity, maxHeight: .infinity)
            } else {
                ScrollView {
                    LazyVGrid(columns: columns, spacing: 12) {
                        ForEach(Array(filteredItems.enumerated()), id: \.element.id) { index, item in
                            ClipboardCardView(
                                item: item,
                                isSelected: selectedIDs.contains(item.persistentModelID)
                            )
                            .onTapGesture {
                                handleTap(item: item, index: index)
                            }
                        }
                    }
                    .padding(12)
                }
            }
        }
        .focusable()
        .focusEffectDisabled()
        .onKeyPress(.init("a"), modifiers: .command) {
            // Cmd+A: select all visible items
            selectedIDs = Set(filteredItems.map(\.persistentModelID))
            return .handled
        }
        .onKeyPress(.escape) {
            // Escape: deselect all
            selectedIDs.removeAll()
            lastClickedID = nil
            return .handled
        }
    }
    ```

    **Multi-selection tap handler:**
    ```swift
    private func handleTap(item: ClipboardItem, index: Int) {
        let id = item.persistentModelID
        let modifiers = NSEvent.modifierFlags

        if modifiers.contains(.command) {
            // Cmd-click: toggle individual selection
            if selectedIDs.contains(id) {
                selectedIDs.remove(id)
            } else {
                selectedIDs.insert(id)
            }
            lastClickedID = id
        } else if modifiers.contains(.shift), let anchorID = lastClickedID {
            // Shift-click: range selection from anchor to clicked item
            // Find indices of anchor and clicked item in current filteredItems
            guard let anchorIndex = filteredItems.firstIndex(where: { $0.persistentModelID == anchorID }) else {
                // Anchor no longer in filtered results, treat as single select
                selectedIDs = [id]
                lastClickedID = id
                return
            }
            let range = min(anchorIndex, index)...max(anchorIndex, index)
            for i in range {
                selectedIDs.insert(filteredItems[i].persistentModelID)
            }
            // Do NOT update lastClickedID on shift-click (anchor stays)
        } else {
            // Plain click: single selection (clears previous)
            selectedIDs = [id]
            lastClickedID = id
        }
    }
    ```

    **Critical details:**
    - Use `@Binding var selectedIDs` so the parent (HistoryBrowserView) owns the selection state and can pass it to the bulk action toolbar.
    - Store anchor as `PersistentIdentifier` (not index) per research pitfall #3 -- stable across filter changes.
    - Use `NSEvent.modifierFlags` (class property, not instance) to detect Cmd/Shift on tap -- same pattern as research code examples.
    - ClipboardCardView does NOT need PanelActions environment here. However, it currently accesses `@Environment(PanelActions.self)`. This will crash in the settings window context. **Solution:** Make the PanelActions environment optional or provide a dummy. Check ClipboardCardView -- if it uses `panelActions` only in the context menu, and the context menu still shows in settings, we need to handle this.

    **Handling PanelActions in ClipboardCardView:**
    ClipboardCardView has `@Environment(PanelActions.self) private var panelActions` and uses it in the context menu for Copy/Paste/Copy+Paste actions. In the settings History browser, these panel-specific actions don't apply. Two options:
    - Option A: Make PanelActions optional with a default value. Too invasive to existing code.
    - Option B: Inject a dummy PanelActions environment from HistoryBrowserView. PanelActions is an @Observable class -- create one and inject it. The context menu buttons will fire closures that are nil (no-op). This is the simplest approach.

    In HistoryBrowserView (updated in Task 2), add `.environment(PanelActions())` to the HistoryGridView. PanelActions' closures default to nil, so context menu Copy/Paste are no-ops in the settings context. The right-click "Delete" and "Label" submenus will still work since they use modelContext directly.
  </action>
  <verify>
    File exists at `Pastel/Views/Settings/HistoryGridView.swift` with LazyVGrid, @Query init, filteredItems, handleTap with Cmd/Shift/plain click logic, Cmd+A and Escape key handlers.
  </verify>
  <done>
    HistoryGridView renders clipboard cards in an adaptive grid. Cmd-click toggles selection. Shift-click selects a range. Cmd+A selects all. Escape deselects. Grid reflows on window resize. Empty state shows "No items found".
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire HistoryGridView into HistoryBrowserView with .id() recreation</name>
  <files>
    Pastel/Views/Settings/HistoryBrowserView.swift
  </files>
  <action>
    Update `HistoryBrowserView` to replace the placeholder with the real HistoryGridView. This wires search, chip bar, and grid together with the critical `.id()` pattern for @Query recreation.

    **Changes to HistoryBrowserView:**
    1. Add `@State private var selectedIDs: Set<PersistentIdentifier> = []` for multi-selection state.
    2. Replace the placeholder `Text("History grid coming soon")` with:
       ```swift
       HistoryGridView(
           searchText: debouncedSearchText,
           selectedLabelIDs: selectedLabelIDs,
           selectedIDs: $selectedIDs
       )
       .environment(PanelActions())
       .id("\(debouncedSearchText)\(selectedLabelIDs.sorted(by: { "\($0)" < "\($1)" }).map { "\($0)" }.joined())")
       ```
    3. The `.id()` string must include `debouncedSearchText` and `selectedLabelIDs` sorted-to-string -- exactly the same pattern as PanelContentView line 117. This forces SwiftUI to destroy and recreate HistoryGridView when filters change, giving it a fresh @Query.
    4. When the `.id()` changes and the view is recreated, `selectedIDs` persists because it lives in the parent (HistoryBrowserView), not in the grid. However, we should clear selection when filters change to avoid stale selections:
       ```swift
       .onChange(of: debouncedSearchText) { _, _ in selectedIDs.removeAll() }
       .onChange(of: selectedLabelIDs) { _, _ in selectedIDs.removeAll() }
       ```
    5. Add `import SwiftData` at the top if not already present (needed for PersistentIdentifier).

    **PanelActions injection:** Add `.environment(PanelActions())` on the HistoryGridView. PanelActions is an @Observable class with optional closures defaulting to nil. This satisfies ClipboardCardView's `@Environment(PanelActions.self)` without crashing. Context menu Copy/Paste will be no-ops (nil closures), but Delete and Label assignment work via modelContext.
  </action>
  <verify>
    `xcodebuild -scheme Pastel build 2>&1 | tail -5` compiles without errors.
    Launch app, open Settings, click History tab. Cards appear in a grid. Resize window -- columns reflow. Type in search -- grid filters. Click a label chip -- grid filters by label. Cmd-click multiple cards -- they highlight. Shift-click -- range selects. Cmd+A selects all. Escape deselects.
  </verify>
  <done>
    HistoryBrowserView composes search + chip bar + HistoryGridView. The .id() pattern forces @Query recreation on filter changes. Selection state is managed in the parent and cleared on filter change. PanelActions is injected as a dummy for ClipboardCardView compatibility.
  </done>
</task>

</tasks>

<verification>
1. `xcodebuild -scheme Pastel build` succeeds
2. History tab shows clipboard cards in responsive grid
3. Window resize causes columns to reflow (1 col at ~500pt, 2 at ~600pt, 3 at ~900pt)
4. Search field filters grid items (by text content, app name, title)
5. Label chip bar filters grid items (OR logic: items with ANY selected label)
6. Cmd-click toggles individual card selection
7. Shift-click selects range from last-clicked card
8. Cmd+A selects all visible cards
9. Escape deselects all cards
10. Selected cards show accent highlight (same visual as panel selection)
</verification>

<success_criteria>
- HistoryGridView uses LazyVGrid with GridItem(.adaptive(minimum: 280, maximum: 400))
- @Query follows init-based pattern with predicate matching FilteredCardListView
- In-memory label filtering (not #Predicate .contains on to-many)
- Multi-selection via Set<PersistentIdentifier> with Cmd-click, Shift-click, Cmd+A, Escape
- Shift-click anchor stored as PersistentIdentifier (stable across filter changes)
- .id() modifier includes search text and sorted label IDs for @Query recreation
- PanelActions injected as dummy to prevent ClipboardCardView environment crash
- Selection cleared when search text or label filter changes
</success_criteria>

<output>
After completion, create `.planning/phases/12-history-browser-and-bulk-actions/12-02-SUMMARY.md`
</output>
